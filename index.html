<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>じゃんけんAI</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Color Variables --- */
        :root {
            --bg-color: #f0f0f0;
            --text-color: #333;
            --container-bg: #fff;
            --container-shadow: rgba(0,0,0,0.1);
            --border-color: #eee;
            --button-bg: #4285F4;
            --button-text: white;
            --button-hover-bg: #357ae8;
            --button-disabled-bg: #ccc;
            --button-disabled-text: #666;
            --secondary-text-color: #555;
            --chart-grid-color: rgba(0, 0, 0, 0.1);
            --chart-label-color: #666;
            --chart-title-color: #333;
            --notification-bg: rgba(0, 0, 0, 0.8);
            --notification-text: white;
            --notification-button-bg: #555;
            --notification-button-hover-bg: #777;
            --danger-button-bg: #f44336;
            --danger-button-hover-bg: #d32f2f;
            --warning-button-bg: #ff9800;
            --warning-button-hover-bg: #fb8c00;
            --accent1-color: rgb(75, 192, 192); /* Player 1 / You */
            --accent2-color: rgb(255, 99, 132); /* Player 2 / AI / User 2 */
            --accent3-color: rgb(201, 203, 207); /* Draw */
            --accent4-color: rgb(153, 102, 255); /* Score Difference */
            --hand-rock-color: rgb(255, 159, 64);
            --hand-paper-color: rgb(54, 162, 235);
            --hand-scissors-color: rgb(255, 205, 86);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #e0e0e0;
                --container-bg: #1e1e1e;
                --container-shadow: rgba(255, 255, 255, 0.1);
                --border-color: #333;
                --button-bg: #5c8fef;
                --button-text: #121212;
                --button-hover-bg: #7faaf0;
                --button-disabled-bg: #444;
                --button-disabled-text: #888;
                --secondary-text-color: #aaa;
                --chart-grid-color: rgba(255, 255, 255, 0.1);
                --chart-label-color: #aaa;
                --chart-title-color: #e0e0e0;
                --notification-bg: rgba(230, 230, 230, 0.9);
                --notification-text: #121212;
                --notification-button-bg: #bbb;
                --notification-button-hover-bg: #ccc;
                --danger-button-bg: #ef5350;
                --danger-button-hover-bg: #e57373;
                --warning-button-bg: #ffa726;
                --warning-button-hover-bg: #ffb74d;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            animation: fadeIn 0.5s ease-out;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            background-color: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px var(--container-shadow);
            width: 100%;
            max-width: 900px;
            box-sizing: border-box;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 0.2s;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        h1, h2, h3, p, button, label, span, div, input, select,
        #scoreboard div, #game-display div,
        #player-controls button, #ai-vs-ai-controls > div, #ai-vs-ai-controls button,
        #chart-container, #hands-chart-container,
        #round-info, #result-text, #turn-indicator,
        .zoom-controls button, .zoom-controls span,
        #hands-stats div
         {
            font-family: 'Roboto', sans-serif;
            color: var(--text-color);
            transition: color 0.3s ease, background-color 0.3s ease;
        }

        .container > h1, .container > #mode-selection > h2, .container > #mode-selection .mode-buttons button,
        .container > #game-length-selection > h2, .container > #game-length-selection #game-length-buttons button,
        #scoreboard > div,
        #game-display > .player-area > div, #game-display > .ai-area > div, #game-display > div[style*="font-size: 1.5em"],
        #round-info,
        #hands-stats > div,
        .zoom-controls > button, .zoom-controls > span
        {
            opacity: 0;
            animation: fadeIn 0.6s ease-out forwards;
        }


         button { color: var(--button-text); }
         button:disabled { color: var(--button-disabled-text); }
         #round-info, #ai-speed-display, .player-area div, .ai-area div, label, #ai-vs-ai-controls span, .zoom-controls span, #player-controls label,
         #hands-stats label
         {
            color: var(--secondary-text-color);
            transition: color 0.3s ease;
         }
         #result-text, #turn-indicator, #score-difference-display { color: var(--text-color); transition: color 0.3s ease;}
         #player-score-display, #ai-score-display, #draw-score-display { font-weight: bold; transition: color 0.3s ease;}
         #score-difference-display { font-weight: normal; transition: color 0.3s ease;}
         #hands-stats span {font-weight: bold; transition: color 0.3s ease;}


        .container > h1 { animation-delay: 0.3s; }
        .container > #mode-selection > h2 { animation-delay: 0.4s; }
        #mode-selection .mode-buttons button:nth-child(1) { animation-delay: 0.5s; }
        #mode-selection .mode-buttons button:nth-child(2) { animation-delay: 0.55s; }
        #mode-selection .mode-buttons button:nth-child(3) { animation-delay: 0.6s; }

        #scoreboard div:nth-child(1) { animation-delay: 0.6s; }
        #scoreboard div:nth-child(2) { animation-delay: 0.65s; }
        #scoreboard div:nth-child(3) { animation-delay: 0.7s; }
        #score-difference-display { animation-delay: 0.75s; }

        #game-display > .player-area > div:first-child { animation-delay: 0.6s; }
        #game-display > .player-area > .hand-display { animation-delay: 0.65s; }
        #game-display > div[style*="font-size: 1.5em"] { animation-delay: 0.7s; }
        #game-display > .ai-area > div:first-child { animation-delay: 0.75s; }
        #game-display > .ai-area > .hand-display { animation-delay: 0.8s; }

        #round-info { animation-delay: 0.85s; }
        #hands-stats { animation-delay: 1.0s; }
        #hands-stats div { animation-delay: 1.05s; }


        .fade-in {
            animation: fadeIn 0.5s ease-out forwards !important;
            opacity: 0;
        }

        .initially-hidden {
            display: none;
            opacity: 0;
        }

        button {
            font-size: 1em;
            padding: 10px 15px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--button-bg);
            color: var(--button-text);
            transition: background-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
        }
        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
        }
        button:disabled {
            background-color: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            cursor: not-allowed;
            opacity: 0.7;
        }
        #quit-button, #ai-quit-button {
             background-color: var(--danger-button-bg);
        }
         #quit-button:hover:not(:disabled), #ai-quit-button:hover:not(:disabled) {
             background-color: var(--danger-button-hover-bg);
         }
         #start-pause-button.paused, #ai-vs-ai-start-stop.paused {
            background-color: var(--warning-button-bg);
         }
         #start-pause-button.paused:hover:not(:disabled), #ai-vs-ai-start-stop.paused:hover:not(:disabled) {
            background-color: var(--warning-button-hover-bg);
         }


        .mode-buttons button, #game-length-buttons button {
             min-width: 80px;
             margin-bottom: 10px;
        }

        #game-area {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
             transition: border-color 0.3s ease;
        }

        #scoreboard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            text-align: center;
        }
        #score-difference-display {
            grid-column: 1 / -1;
            margin-top: 10px;
            font-size: 1em;
            color: var(--secondary-text-color);
        }

        #game-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 30px;
            min-height: 100px;
        }

        .player-area, .ai-area {
            text-align: center;
        }

        .hand-display {
            font-size: 3em;
            min-width: 60px;
            min-height: 60px;
            display: inline-block;
            line-height: 60px;
            transition: opacity 0.3s ease;
        }

        #player-controls, #ai-vs-ai-controls {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #player-controls > div, #ai-vs-ai-controls > div {
             display: flex;
             flex-wrap: wrap;
             justify-content: center;
             align-items: center;
             gap: 10px;
        }
        #ai-vs-ai-controls label, #ai-vs-ai-controls input, #ai-vs-ai-controls span { color: var(--secondary-text-color); transition: color 0.3s ease;}
        #turn-indicator {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            min-height: 1.2em;
            transition: color 0.3s ease;
        }

        #chart-container, #hands-chart-container {
            width: 100%;
            max-width: 100%;
            height: 400px;
            margin: 25px auto;
            background-color: var(--container-bg);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px var(--container-shadow);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        #resultsChart, #handsChart {
            width: 100% !important;
            height: 100% !important;
        }

        #hands-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            font-size: 0.9em;
        }
        #hands-stats div {
            padding: 8px;
            background-color: var(--bg-color);
            border-radius: 5px;
        }
        #hands-stats h4 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.1em;
            color: var(--chart-title-color);
        }
        #hands-stats p {
            margin: 4px 0;
        }
        #hands-stats .hand-rock { color: var(--hand-rock-color); }
        #hands-stats .hand-paper { color: var(--hand-paper-color); }
        #hands-stats .hand-scissors { color: var(--hand-scissors-color); }


        #notification-area {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--notification-bg);
            color: var(--notification-text);
            padding: 15px 30px;
            border-radius: 5px;
            z-index: 1000;
            text-align: center;
            opacity: 0;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
            cursor: pointer;
        }
        #notification-area.fade-in {
             display: block;
             animation: fadeIn 0.5s ease-out forwards;
        }
        #notification-area button {
            background-color: var(--notification-button-bg);
            color: var(--notification-text);
            margin-top: 10px;
             transition: background-color 0.3s ease;
        }
         #notification-area button:hover {
            background-color: var(--notification-button-hover-bg);
        }
        #notification-message {
            margin-bottom: 10px;
            opacity: 1;
            animation: none;
            color: var(--notification-text);
            transition: color 0.3s ease;
        }

        #ai-speed-slider {
            width: 200px;
            margin: 0 10px;
            cursor: pointer;
            accent-color: var(--button-bg);
        }

        .result-text {
            font-weight: bold;
            margin-top: 10px;
            font-size: 1.2em;
            color: var(--text-color);
            transition: color 0.3s ease;
            min-height: 1.5em;
        }

        #player-hand, #ai-hand {
             opacity: 1;
        }

        input[type=range] {
          -webkit-appearance: none; appearance: none;
          width: 200px; height: 8px; background: var(--border-color);
          outline: none; border-radius: 4px; transition: background 0.3s ease;
          vertical-align: middle;
        }
        input[type=range]::-webkit-slider-thumb {
          -webkit-appearance: none; appearance: none;
          width: 20px; height: 20px; background: var(--button-bg);
          cursor: pointer; border-radius: 50%; transition: background 0.3s ease;
        }
        input[type=range]::-moz-range-thumb {
          width: 20px; height: 20px; background: var(--button-bg);
          cursor: pointer; border-radius: 50%; border: none; transition: background 0.3s ease;
        }
         input[type=range]::-moz-range-track {
            background: var(--border-color); height: 8px; border-radius: 4px; transition: background 0.3s ease;
         }

        .switch {
          position: relative;
          display: inline-block;
          width: 44px;
          height: 24px;
          vertical-align: middle;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
          position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
          background-color: #ccc; transition: .4s;
        }
        .slider:before {
          position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
          background-color: white; transition: .4s;
        }
        input:checked + .slider { background-color: var(--button-bg); }
        input:focus + .slider { box-shadow: 0 0 1px var(--button-bg); }
        input:checked + .slider:before { transform: translateX(20px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        .zoom-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        .zoom-controls > span {
            display: inline-flex;
            align-items: center;
        }
         .zoom-controls span label, .zoom-controls span span {
             color: var(--secondary-text-color);
             transition: color 0.3s ease;
             vertical-align: middle;
             margin-left: 5px;
         }
    </style>
</head>
<body>
    <div class="container">
        <h1>じゃんけんAI</h1>

        <div id="mode-selection">
            <h2>モード選択</h2>
            <div class="mode-buttons">
                <button onclick="selectMode('player-vs-ai')">あなた VS AI</button>
                <button onclick="selectMode('ai-vs-ai')">AI VS AI</button>
                <button onclick="selectMode('player-vs-player')">あなた VS ユーザー2</button>
            </div>
        </div>

        <div id="game-length-selection" class="initially-hidden">
            <h2>勝負回数選択</h2>
            <div id="game-length-buttons">
                <button onclick="setGameLength(1)">1回勝負</button>
                <button onclick="setGameLength(5)">5回勝負</button>
                <button onclick="setGameLength(10)">10回勝負</button>
                <button onclick="setGameLength(25)">25回勝負</button>
                <button onclick="setGameLength(50)">50回勝負</button>
                <button onclick="setGameLength(100)">100回勝負</button>
                <button onclick="setGameLength(250)">250回勝負</button>
                <button onclick="setGameLength(500)">500回勝負</button>
                <button onclick="setGameLength(1000)">1,000回勝負</button>
                <button onclick="setGameLength(Infinity)">∞</button>
            </div>
        </div>

        <div id="game-area" class="initially-hidden">
            <div id="scoreboard">
                 <div id="player-score-display">あなた: 0</div>
                 <div id="draw-score-display">あいこ: 0</div>
                 <div id="ai-score-display">AI: 0</div>
                 <div id="score-difference-display">同点</div>
            </div>
             <div id="round-info" style="text-align: center; margin-bottom: 15px; font-size: 0.9em;">ラウンド: 0 / 0</div>

            <div id="game-display">
                <div class="player-area">
                    <div id="player-name">あなた</div>
                    <div id="player-hand" class="hand-display">?</div>
                </div>
                <div style="font-size: 1.5em; font-weight: bold;">VS</div>
                <div class="ai-area">
                     <div id="ai-name">AI</div>
                    <div id="ai-hand" class="hand-display">?</div>
                </div>
            </div>

             <div id="result-text" class="result-text" style="text-align: center;">結果を待っています...</div>
             <div id="turn-indicator" style="text-align: center;" class="initially-hidden"></div>


            <div id="player-controls" class="initially-hidden">
                 <div>
                    <h3 id="player-controls-title" style="margin: 0 10px 0 0; animation: none; opacity: 1;">あなたの手を選択してください:</h3>
                    <button onclick="playerChoose('rock')">✊ グー</button>
                    <button onclick="playerChoose('paper')">✋ パー</button>
                    <button onclick="playerChoose('scissors')">✌️ チョキ</button>
                 </div>
                 <div>
                    <button id="start-pause-button" onclick="toggleStartPause()">スタート</button>
                    <button id="quit-button" onclick="quitGame()">辞める</button>
                 </div>
            </div>

            <div id="ai-vs-ai-controls" class="initially-hidden">
                <div>
                    <label for="ai-speed-slider" style="animation: none; opacity: 1;">対戦速度 (回/秒):</label>
                    <input type="range" id="ai-speed-slider" min="1" max="200" value="10" oninput="updateSpeedDisplay(this.value)" style="animation: none; opacity: 1;">
                    <span id="ai-speed-display" style="animation: none; opacity: 1;">10</span> <span style="animation: none; opacity: 1;">回/秒</span>
                </div>
                <div>
                    <button id="ai-vs-ai-start-stop" onclick="toggleStartPause()">スタート</button>
                    <button id="ai-quit-button" onclick="quitGame()">辞める</button>
                </div>
            </div>

            <div id="hands-stats" class="initially-hidden">
                <div id="player1-hands-stats">
                    <h4 id="player1-hands-title">あなたの手の内訳</h4>
                    <p><label>✊ グー:</label> <span id="p1-rock-count" class="hand-rock">0</span></p>
                    <p><label>✋ パー:</label> <span id="p1-paper-count" class="hand-paper">0</span></p>
                    <p><label>✌️ チョキ:</label> <span id="p1-scissors-count" class="hand-scissors">0</span></p>
                </div>
                <div id="player2-hands-stats">
                    <h4 id="player2-hands-title">AIの手の内訳</h4>
                    <p><label>✊ グー:</label> <span id="p2-rock-count" class="hand-rock">0</span></p>
                    <p><label>✋ パー:</label> <span id="p2-paper-count" class="hand-paper">0</span></p>
                    <p><label>✌️ チョキ:</label> <span id="p2-scissors-count" class="hand-scissors">0</span></p>
                </div>
            </div>
        </div>


        <div id="chart-container" class="initially-hidden">
            <canvas id="resultsChart"></canvas>
            <div class="zoom-controls initially-hidden">
                <button onclick="resetZoom('resultsChart')" id="reset-zoom-button">ズームリセット (勝敗)</button>
                <span>
                    <label class="switch" style="animation: none; opacity: 1;">
                        <input type="checkbox" id="zoom-toggle-switch" onchange="toggleZoomSwitch(this.checked, 'resultsChart')" checked>
                        <span class="slider round"></span>
                    </label>
                    <span style="animation: none; opacity: 1;">ズーム有効</span>
                </span>
            </div>
        </div>

        <div id="hands-chart-container" class="initially-hidden">
            <canvas id="handsChart"></canvas>
             <div class="zoom-controls initially-hidden">
                <button onclick="resetZoom('handsChart')" id="reset-hands-zoom-button">ズームリセット (手の内訳)</button>
                 <span>
                    <label class="switch" style="animation: none; opacity: 1;">
                        <input type="checkbox" id="hands-zoom-toggle-switch" onchange="toggleZoomSwitch(this.checked, 'handsChart')" checked>
                        <span class="slider round"></span>
                    </label>
                    <span style="animation: none; opacity: 1;">ズーム有効</span>
                </span>
            </div>
        </div>

    </div>

    <div id="notification-area" onclick="hideNotification()">
        <p id="notification-message">メッセージ</p>
    </div>

    <script>
        Chart.defaults.font.family = "'Roboto', sans-serif";

        const HANDS = ['rock', 'paper', 'scissors'];
        const HAND_EMOJIS_ARRAY = ['✊', '✋', '✌️']; // For bar chart labels
        const HAND_EMOJIS = { rock: '✊', paper: '✋', scissors: '✌️' };
        const WIN_CONDITIONS = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
        const UNITS = {
             3: 'K',  6: 'M',  9: 'B', 12: 'T', 15: 'Q', 18: 'Qu', 21: 'Sx', 24: 'Sp',
            27: 'O', 30: 'N', 33: 'D', 36: 'Ud', 39: 'Duo', 42: 'Tre', 45: 'Qua',
            48: 'Qd', 51: 'Sd', 54: 'Sepd', 57: 'Oct', 60: 'NV', 63: 'V', 66: 'UNV',
            69: 'A', 72: 'C', 75: 'E', 78: 'F', 81: 'G', 84: 'H', 87: 'I', 90: 'J',
            93: 'L', 96: 'P'
        };
        const UNIT_KEYS = Object.keys(UNITS).map(Number).sort((a, b) => b - a);

        let gameMode = '';
        let currentGameLength = 0;
        let currentRound = 0;
        let scores = {
            player1: 0, player2: 0, draw: 0,
            player1Hands: { rock: 0, paper: 0, scissors: 0 },
            player2Hands: { rock: 0, paper: 0, scissors: 0 }
        };
        let playerHistory = [];
        let ai1History = [];
        let ai2History = [];

        let resultsChartInstance = null;
        let handsChartInstance = null; // Now for Bar Chart
        let resultsChartData = { labels: [], datasets: [] };
        // handsChartData is not used in the same way for bar chart, data is set directly in instance

        let aiVsAiIntervalId = null;
        let aiVsAiSpeed = 10;
        let isAiVsAiRunning = false;
        let isGameOver = false;
        let isGamePaused = true;
        let colorSchemeMatcher = window.matchMedia('(prefers-color-scheme: dark)');
        let notificationTimeoutId = null;
        let isNotificationVisible = false;
        let currentPlayerTurn = 'player1';
        let player1HandChoice = null;
        let roundResetTimeoutId = null;

        let isResultsZoomEnabled = true;
        let isHandsZoomEnabled = true; // Will be less useful for bar chart


        const modeSelectionDiv = document.getElementById('mode-selection');
        const gameLengthSelectionDiv = document.getElementById('game-length-selection');
        const gameAreaDiv = document.getElementById('game-area');
        const scoreboardPlayerDisplay = document.getElementById('player-score-display');
        const scoreboardDrawDisplay = document.getElementById('draw-score-display');
        const scoreboardAiDisplay = document.getElementById('ai-score-display');
        const scoreDifferenceDisplay = document.getElementById('score-difference-display');
        const roundInfoDisplay = document.getElementById('round-info');
        const playerNameDisplay = document.getElementById('player-name');
        const aiNameDisplay = document.getElementById('ai-name');
        const playerHandDisplay = document.getElementById('player-hand');
        const aiHandDisplay = document.getElementById('ai-hand');
        const resultTextDisplay = document.getElementById('result-text');
        const turnIndicator = document.getElementById('turn-indicator');
        const playerControlsDiv = document.getElementById('player-controls');
        const playerControlsTitle = document.getElementById('player-controls-title');
        const aiVsAiControlsDiv = document.getElementById('ai-vs-ai-controls');
        const aiSpeedSlider = document.getElementById('ai-speed-slider');
        const aiSpeedDisplay = document.getElementById('ai-speed-display');
        const startPauseButton = document.getElementById('start-pause-button');
        const aiVsAiStartStopButton = document.getElementById('ai-vs-ai-start-stop');
        const chartContainerDiv = document.getElementById('chart-container');
        const handsChartContainerDiv = document.getElementById('hands-chart-container');
        const notificationArea = document.getElementById('notification-area');
        const notificationMessage = document.getElementById('notification-message');
        const quitButton = document.getElementById('quit-button');
        const aiQuitButton = document.getElementById('ai-quit-button');
        const playerChoiceButtons = playerControlsDiv.querySelectorAll('button:not(#start-pause-button):not(#quit-button)');

        const handsStatsDiv = document.getElementById('hands-stats');
        const p1HandsTitle = document.getElementById('player1-hands-title');
        const p2HandsTitle = document.getElementById('player2-hands-title');
        const p1RockCount = document.getElementById('p1-rock-count');
        const p1PaperCount = document.getElementById('p1-paper-count');
        const p1ScissorsCount = document.getElementById('p1-scissors-count');
        const p2RockCount = document.getElementById('p2-rock-count');
        const p2PaperCount = document.getElementById('p2-paper-count');
        const p2ScissorsCount = document.getElementById('p2-scissors-count');

        const resultsZoomToggleSwitch = document.getElementById('zoom-toggle-switch');
        const handsZoomToggleSwitch = document.getElementById('hands-zoom-toggle-switch');
        const resultsZoomControlsDiv = chartContainerDiv.querySelector('.zoom-controls');
        const handsZoomControlsDiv = handsChartContainerDiv.querySelector('.zoom-controls');


        window.onload = () => {
            loadGameData();
            colorSchemeMatcher.addEventListener('change', handleColorSchemeChange);
            updateScoreboard();
            updateHandsStatsUI();
            resetHandDisplays();
            isGamePaused = true;
            hideElement(playerControlsDiv);
            hideElement(aiVsAiControlsDiv);
            const noJsInitialFade = [
                playerControlsTitle, aiSpeedSlider, aiSpeedDisplay,
                document.querySelector('#ai-vs-ai-controls label[for="ai-speed-slider"]'),
                document.querySelector('#ai-vs-ai-controls span:last-of-type'),
                resultsZoomControlsDiv.querySelector('.switch'),
                resultsZoomControlsDiv.querySelector('span span'),
                handsZoomControlsDiv.querySelector('.switch'),
                handsZoomControlsDiv.querySelector('span span'),
            ];
            noJsInitialFade.forEach(el => {
                if (el) {
                    el.style.animation = 'none';
                    el.style.opacity = '1';
                }
            });
        };

        function handleColorSchemeChange(e) {
            if (resultsChartInstance) {
                updateChartColors(resultsChartInstance);
                resultsChartInstance.update();
            }
            if (handsChartInstance) { // For Bar chart
                updateChartColors(handsChartInstance, true); // Pass isBarChart = true
                handsChartInstance.update();
            }
            updateStartPauseButtonState();
        }

        function getChartColors() {
            const style = getComputedStyle(document.documentElement);
            return {
                gridColor: style.getPropertyValue('--chart-grid-color').trim(),
                labelColor: style.getPropertyValue('--chart-label-color').trim(),
                titleColor: style.getPropertyValue('--chart-title-color').trim(),
                accent1: style.getPropertyValue('--accent1-color').trim(),
                accent2: style.getPropertyValue('--accent2-color').trim(),
                accent3: style.getPropertyValue('--accent3-color').trim(),
                accent4: style.getPropertyValue('--accent4-color').trim(),
                handRock: style.getPropertyValue('--hand-rock-color').trim(),
                handPaper: style.getPropertyValue('--hand-paper-color').trim(),
                handScissors: style.getPropertyValue('--hand-scissors-color').trim(),
            };
        }

        // Modified to handle bar chart dataset colors
         function updateChartColors(chart, isBarChart = false) {
             if (!chart) return;
             const colors = getChartColors();

            if (isBarChart) {
                chart.data.datasets.forEach((dataset, index) => {
                    // For bar chart, P1 and P2 datasets will have specific colors
                    if (dataset.label.includes('あなた') || dataset.label.includes('AI 1') || dataset.label.includes('P1')) {
                        dataset.backgroundColor = colors.accent1; // Or more specific if needed
                        dataset.borderColor = colors.accent1;
                    } else if (dataset.label.includes('AI') || dataset.label.includes('ユーザー2') || dataset.label.includes('P2')) {
                        dataset.backgroundColor = colors.accent2;
                        dataset.borderColor = colors.accent2;
                    }
                });
            } else { // Line chart (results chart)
                 chart.data.datasets.forEach(dataset => {
                     if (dataset.label.includes('あなた') || dataset.label.includes('AI 1')) { dataset.borderColor = colors.accent1; }
                     else if (dataset.label.includes('AI') || dataset.label.includes('ユーザー2')) { dataset.borderColor = colors.accent2; }
                     else if (dataset.label.includes('あいこ')) { dataset.borderColor = colors.accent3; }
                     else if (dataset.label.includes('スコア差')) { dataset.borderColor = colors.accent4; }
                 });
            }


             if (chart.options.scales.x) {
                chart.options.scales.x.grid.color = colors.gridColor;
                chart.options.scales.x.ticks.color = colors.labelColor;
                chart.options.scales.x.title.color = colors.titleColor;
             }
             if (chart.options.scales.y) {
                chart.options.scales.y.grid.color = colors.gridColor;
                chart.options.scales.y.ticks.color = colors.labelColor;
                chart.options.scales.y.title.color = colors.titleColor;
             }
              if (chart.options.scales.y1 && !isBarChart) { // y1 only for results line chart
                 chart.options.scales.y1.grid.color = colors.gridColor;
                 chart.options.scales.y1.ticks.color = colors.labelColor;
                 chart.options.scales.y1.title.color = colors.titleColor;
             }
             if (chart.options.plugins.legend) chart.options.plugins.legend.labels.color = colors.labelColor;
             if (chart.options.plugins.title) chart.options.plugins.title.color = colors.titleColor;
         }

        function selectMode(mode) {
            if (isNotificationVisible) hideNotification(true);
            gameMode = mode;
            hideElement(modeSelectionDiv);
            fadeInElement(gameLengthSelectionDiv);

            let p1Name = 'あなた', p2Name = 'AI';
            let p1HandsLabel = 'あなたの手の内訳', p2HandsLabel = 'AIの手の内訳';
            if (mode === 'ai-vs-ai') {
                p1Name = 'AI 1'; p2Name = 'AI 2';
                p1HandsLabel = 'AI 1の手の内訳'; p2HandsLabel = 'AI 2の手の内訳';
            } else if (mode === 'player-vs-player') {
                p1Name = 'あなた'; p2Name = 'ユーザー2';
                p1HandsLabel = 'あなたの手の内訳'; p2HandsLabel = 'ユーザー2の手の内訳';
            }
            fadeInElementText(playerNameDisplay, p1Name);
            fadeInElementText(aiNameDisplay, p2Name);
            fadeInElementText(p1HandsTitle, p1HandsLabel);
            fadeInElementText(p2HandsTitle, p2HandsLabel);

            resetGameFullState();
            fadeInElementText(resultTextDisplay, '勝負回数を選択してください...');
            hideElement(resultsZoomControlsDiv);
            hideElement(handsZoomControlsDiv);
            hideElement(handsStatsDiv);
        }

        function setGameLength(length) {
            if (isNotificationVisible) hideNotification(true);
            currentGameLength = length;
            resetGameFullState();
            updateScoreboard();
            updateRoundInfo();
            updateHandsStatsUI();
            resetHandDisplays();

            hideElement(gameLengthSelectionDiv);
            fadeInElement(gameAreaDiv);
            fadeInElement(handsStatsDiv);
            fadeInElement(chartContainerDiv);
            fadeInElement(handsChartContainerDiv);


            isResultsZoomEnabled = true;
            isHandsZoomEnabled = true; // Keep for consistency, though less useful for bar
            initializeResultsChart();
            initializeHandsBarChart(); // Changed to bar chart init
            fadeInElement(resultsZoomControlsDiv);
            fadeInElement(handsZoomControlsDiv);
            resultsZoomToggleSwitch.checked = isResultsZoomEnabled;
            handsZoomToggleSwitch.checked = isHandsZoomEnabled;


            hideElement(playerControlsDiv);
            hideElement(aiVsAiControlsDiv);
            hideElement(turnIndicator);
            isGamePaused = true;

            if (gameMode === 'player-vs-ai' || gameMode === 'player-vs-player') {
                fadeInElement(playerControlsDiv);
                enablePlayerChoices(false);
                fadeInElement(startPauseButton);
                fadeInElement(quitButton);
                if (gameMode === 'player-vs-player') {
                    fadeInElement(turnIndicator);
                }
            } else if (gameMode === 'ai-vs-ai') {
                fadeInElement(aiVsAiControlsDiv);
                aiSpeedSlider.disabled = false;
                fadeInElement(aiVsAiStartStopButton);
                fadeInElement(aiQuitButton);
            }
            updateStartPauseButtonState();
            fadeInElementText(resultTextDisplay, '「スタート」を押してゲームを開始してください。');
        }


        function toggleStartPause() {
            if (isGameOver) return;
            isGamePaused = !isGamePaused;
            clearTimeout(roundResetTimeoutId);
            if (gameMode === 'ai-vs-ai') {
                if (!isGamePaused) { startAiVsAi(); }
                else { stopAiVsAi(); }
            } else {
                if (!isGamePaused) {
                    enablePlayerChoices(true);
                    updateTurnIndicator();
                    fadeInElementText(resultTextDisplay, getWaitingMessage());
                } else {
                    enablePlayerChoices(false);
                    fadeInElementText(resultTextDisplay, '一時停止中... 「スタート」で再開します。');
                }
            }
            updateStartPauseButtonState();
        }

        function updateStartPauseButtonState() {
            let button = (gameMode === 'ai-vs-ai') ? aiVsAiStartStopButton : startPauseButton;
            if (isGameOver) {
                button.textContent = '終了'; button.disabled = true; button.classList.remove('paused');
            } else if (isGamePaused) {
                button.textContent = 'スタート'; button.disabled = false; button.classList.remove('paused');
            } else {
                button.textContent = '一時停止'; button.disabled = false; button.classList.add('paused');
            }
        }

        function quitGame() {
            if (isGameOver) return;
            isGameOver = true; isGamePaused = true;
            clearTimeout(roundResetTimeoutId); clearTimeout(notificationTimeoutId);
            if (gameMode === 'ai-vs-ai') {
                if (isAiVsAiRunning) stopAiVsAi();
                aiSpeedSlider.disabled = true; aiVsAiStartStopButton.disabled = true; hideElement(aiQuitButton);
            } else {
                enablePlayerChoices(false); startPauseButton.disabled = true; hideElement(quitButton); hideElement(turnIndicator);
            }
            let finalMessage = `勝負終了！ (${formatNumber(scores.player1)} 対 ${formatNumber(scores.player2)}`;
            if (scores.draw > 0) finalMessage += ` あいこ ${formatNumber(scores.draw)}回`;
            finalMessage += `) `;
            let p1FinalName = playerNameDisplay.textContent.split(':')[0].trim();
            let p2FinalName = aiNameDisplay.textContent.split(':')[0].trim();
            if (scores.player1 > scores.player2) finalMessage += `${p1FinalName}の勝ちです！`;
            else if (scores.player2 > scores.player1) finalMessage += `${p2FinalName}の勝ちです！`;
            else finalMessage += "引き分けです！";
            fadeInElementText(resultTextDisplay, finalMessage);
            showNotification(finalMessage, false, true, 4000);
            setTimeout(resetForNewGameSelection, 4500);
        }

        function playerChoose(chosenHand) {
            if (isGamePaused || isGameOver) return;
            clearTimeout(roundResetTimeoutId);

            if (gameMode === 'player-vs-ai') {
                enablePlayerChoices(false);
                const aiHand = getAiHand(playerHistory);
                playerHistory.push(chosenHand);
                if (playerHistory.length > 500) playerHistory.shift();
                playRound(chosenHand, aiHand);
            } else if (gameMode === 'player-vs-player') {
                handlePlayerVsPlayerChoice(chosenHand);
            }
        }


        function handlePlayerVsPlayerChoice(hand) {
            if (isGamePaused || isGameOver) return;

            if (currentPlayerTurn === 'player1') {
                player1HandChoice = hand;
                currentPlayerTurn = 'player2';
                playerHandDisplay.textContent = '❔';
                aiHandDisplay.textContent = '?';
                updateTurnIndicator();
                enablePlayerChoices(true);
                fadeInElementText(resultTextDisplay, getWaitingMessage());
            } else {
                const player2HandChoice = hand;
                if (!player1HandChoice) {
                    console.error("Player 1 hand not chosen in P vs P mode.");
                    return;
                }
                enablePlayerChoices(false);
                playRound(player1HandChoice, player2HandChoice);
                player1HandChoice = null;
                currentPlayerTurn = 'player1';
            }
        }

        function playRound(hand1, hand2) {
            if (isGameOver) return;
            clearTimeout(roundResetTimeoutId);
            currentRound++;

            scores.player1Hands[hand1]++;
            scores.player2Hands[hand2]++;

            const winner = determineWinner(hand1, hand2);
            if (winner === 'player1') scores.player1++;
            else if (winner === 'player2') scores.player2++;
            else scores.draw++;

            updateScoreboard();
            updateRoundInfo();
            updateHandsStatsUI();
            updateHandDisplays(hand1, hand2);

            let p1Name = playerNameDisplay.textContent.split(':')[0].trim();
            let p2Name = aiNameDisplay.textContent.split(':')[0].trim();
            let winnerName = (winner === 'player1') ? `${p1Name}の勝ち！` : (winner === 'player2') ? `${p2Name}の勝ち！` : "あいこ！";
            fadeInElementText(resultTextDisplay, winnerName);

            updateResultsChart();
            updateHandsBarChart(); // Changed to update bar chart
            if (gameMode === 'player-vs-ai') saveGameData();

            checkGameEnd();

            if (!isGameOver && !isGamePaused) {
                const delay = (gameMode === 'ai-vs-ai') ? Math.max(50, (1000 / aiVsAiSpeed) * 0.7) : 1500;
                roundResetTimeoutId = setTimeout(() => {
                    if (isGameOver || isGamePaused) return;
                    resetHandDisplays();
                    fadeInElementText(resultTextDisplay, getWaitingMessage());
                    if (gameMode !== 'ai-vs-ai') {
                        enablePlayerChoices(true);
                        updateTurnIndicator();
                    }
                }, delay);
            } else if (isGameOver) {
                enablePlayerChoices(false);
                updateStartPauseButtonState();
            }
        }

        function determineWinner(hand1, hand2) {
            if (hand1 === hand2) return 'draw';
            return (WIN_CONDITIONS[hand1] === hand2) ? 'player1' : 'player2';
        }

        function getAiHand(history) {
            const historyLength = history.length;
            const explorationRate = 0.20;
            if (Math.random() < explorationRate || historyLength < 5) {
                return HANDS[Math.floor(Math.random() * HANDS.length)];
            }
            const lookback = Math.min(historyLength, 10);
            const recentHistory = history.slice(-lookback);
            const counts = recentHistory.reduce((acc, move) => {
                acc[move] = (acc[move] || 0) + 1; return acc;
            }, {});
            let mostFrequentMove = null, maxCount = 0;
            for (const move in counts) {
                if (counts[move] > maxCount) { maxCount = counts[move]; mostFrequentMove = move; }
                else if (counts[move] === maxCount) { mostFrequentMove = null; }
            }
            if (mostFrequentMove && maxCount > lookback / 2.5) {
                const winningMove = Object.keys(WIN_CONDITIONS).find(key => WIN_CONDITIONS[key] === mostFrequentMove);
                if (winningMove) return winningMove;
            }
            const lastMove = history[historyLength - 1];
            const counterMove = Object.keys(WIN_CONDITIONS).find(key => WIN_CONDITIONS[key] === lastMove);
            if (counterMove && Math.random() < 0.6) return counterMove;
            return HANDS[Math.floor(Math.random() * HANDS.length)];
        }


        function checkGameEnd() {
             if (isGameOver) return;
             if (currentGameLength !== Infinity && currentRound >= currentGameLength) {
                 isGameOver = true; isGamePaused = true; clearTimeout(roundResetTimeoutId);
                 let finalMessage = `勝負終了！ (${formatNumber(scores.player1)} 対 ${formatNumber(scores.player2)}`;
                 if (scores.draw > 0) finalMessage += ` あいこ ${formatNumber(scores.draw)}回`;
                 finalMessage += `) `;
                 let p1FinalName = playerNameDisplay.textContent.split(':')[0].trim();
                 let p2FinalName = aiNameDisplay.textContent.split(':')[0].trim();
                 if (scores.player1 > scores.player2) finalMessage += `${p1FinalName}の勝ちです！`;
                 else if (scores.player2 > scores.player1) finalMessage += `${p2FinalName}の勝ちです！`;
                 else finalMessage += "引き分けです！";
                 fadeInElementText(resultTextDisplay, finalMessage);
                 showNotification(finalMessage, false, true, 4000);
                 enablePlayerChoices(false);
                 if (gameMode === 'ai-vs-ai') {
                     if (isAiVsAiRunning) stopAiVsAi();
                     aiSpeedSlider.disabled = true; aiVsAiStartStopButton.disabled = true; hideElement(aiQuitButton);
                 } else {
                     startPauseButton.disabled = true; hideElement(quitButton); hideElement(turnIndicator);
                 }
                 updateStartPauseButtonState();
                 setTimeout(resetForNewGameSelection, 4500);
             }
        }

        function resetForNewGameSelection() {
             hideElement(gameAreaDiv);
             hideElement(chartContainerDiv);
             hideElement(handsChartContainerDiv);
             hideElement(playerControlsDiv);
             hideElement(aiVsAiControlsDiv);
             hideElement(turnIndicator);
             hideElement(resultsZoomControlsDiv);
             hideElement(handsZoomControlsDiv);
             hideElement(handsStatsDiv);
             hideElement(quitButton); hideElement(aiQuitButton);
             fadeInElement(modeSelectionDiv);
             hideElement(gameLengthSelectionDiv);
             if (resultsChartInstance) { resultsChartInstance.destroy(); resultsChartInstance = null; }
             if (handsChartInstance) { handsChartInstance.destroy(); handsChartInstance = null; } // For bar chart
             resultsChartData = { labels: [], datasets: [] };
             // handsChartData is not needed for bar chart state in this way
             resetGameFullState();
             gameMode = '';
             updateScoreboard();
             updateHandsStatsUI();
             resetHandDisplays();
             fadeInElementText(resultTextDisplay, '');
             fadeInElementText(roundInfoDisplay, '');
             if (isNotificationVisible) hideNotification(true);
        }

        function startAiVsAi() {
            if (isGameOver || isAiVsAiRunning) return;
            isAiVsAiRunning = true; isGamePaused = false;
            aiSpeedSlider.disabled = true;
            fadeInElementText(resultTextDisplay, '対戦中...');
            updateStartPauseButtonState(); runAiVsAiRound();
        }
        function stopAiVsAi() {
            if (!isAiVsAiRunning && !isGamePaused && !isGameOver) return;
            isAiVsAiRunning = false; isGamePaused = true;
            clearInterval(aiVsAiIntervalId); aiVsAiIntervalId = null;
            if (!isGameOver) {
                aiSpeedSlider.disabled = false;
                fadeInElementText(resultTextDisplay, '一時停止中... 「スタート」で再開します。');
            } else { aiSpeedSlider.disabled = true; }
            updateStartPauseButtonState();
        }
        function runAiVsAiRound() {
             if (isGameOver || isGamePaused || !isAiVsAiRunning) {
                 clearInterval(aiVsAiIntervalId); aiVsAiIntervalId = null; isAiVsAiRunning = false;
                 if (!isGameOver) updateStartPauseButtonState(); return;
             }
             const ai1Hand = getAiHand(ai2History); const ai2Hand = getAiHand(ai1History);
             ai1History.push(ai1Hand); ai2History.push(ai2Hand);
             const MAX_AI_HISTORY = 200;
             if (ai1History.length > MAX_AI_HISTORY) ai1History.shift();
             if (ai2History.length > MAX_AI_HISTORY) ai2History.shift();
             playRound(ai1Hand, ai2Hand);
             if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                 clearInterval(aiVsAiIntervalId); aiVsAiIntervalId = null;
                 setTimeout(() => {
                     if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                         aiVsAiIntervalId = setInterval(runAiVsAiRound, 1000 / aiVsAiSpeed);
                    }
                 }, 50);
             } else { clearInterval(aiVsAiIntervalId); aiVsAiIntervalId = null; }
        }
        function updateSpeedDisplay(value) {
            aiVsAiSpeed = parseInt(value, 10);
            aiSpeedDisplay.textContent = aiVsAiSpeed;
            if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                clearInterval(aiVsAiIntervalId); aiVsAiIntervalId = null;
                setTimeout(() => {
                    if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                         aiVsAiIntervalId = setInterval(runAiVsAiRound, 1000 / aiVsAiSpeed);
                    }
                }, 50);
            }
        }

        function updateScoreboard() {
            let p1Label = playerNameDisplay.textContent.split(':')[0].trim() || 'Player 1';
            let p2Label = aiNameDisplay.textContent.split(':')[0].trim() || 'Player 2';
            fadeInElementText(scoreboardPlayerDisplay, `${p1Label}: ${formatNumber(scores.player1)}`);
            fadeInElementText(scoreboardDrawDisplay, `あいこ: ${formatNumber(scores.draw)}`);
            fadeInElementText(scoreboardAiDisplay, `${p2Label}: ${formatNumber(scores.player2)}`);
            const diff = scores.player1 - scores.player2;
            let diffText = '同点';
            if (diff > 0) diffText = `${p1Label} が ${formatNumber(diff)} リード`;
            else if (diff < 0) diffText = `${p2Label} が ${formatNumber(Math.abs(diff))} リード`;
            fadeInElementText(scoreDifferenceDisplay, diffText);
        }
        function updateRoundInfo() {
             const lengthDisplay = currentGameLength === Infinity ? '∞' : formatNumber(currentGameLength);
             fadeInElementText(roundInfoDisplay, `ラウンド: ${formatNumber(currentRound)} / ${lengthDisplay}`);
         }

        function updateHandsStatsUI() {
            fadeInElementText(p1RockCount, formatNumber(scores.player1Hands.rock));
            fadeInElementText(p1PaperCount, formatNumber(scores.player1Hands.paper));
            fadeInElementText(p1ScissorsCount, formatNumber(scores.player1Hands.scissors));
            fadeInElementText(p2RockCount, formatNumber(scores.player2Hands.rock));
            fadeInElementText(p2PaperCount, formatNumber(scores.player2Hands.paper));
            fadeInElementText(p2ScissorsCount, formatNumber(scores.player2Hands.scissors));
        }

        function updateTurnIndicator() {
             if (gameMode !== 'player-vs-player' || isGamePaused || isGameOver) {
                 hideElement(turnIndicator);
                 playerControlsTitle.textContent = 'あなたの手を選択してください:';
                 return;
             }
             fadeInElement(turnIndicator);
             const turnPlayerName = (currentPlayerTurn === 'player1') ?
                                    playerNameDisplay.textContent.split(':')[0].trim() :
                                    aiNameDisplay.textContent.split(':')[0].trim();
             const message = `${turnPlayerName}の番: 手を選択してください`;
             fadeInElementText(turnIndicator, message);
             playerControlsTitle.textContent = `${turnPlayerName}の番:`;
         }

         function getWaitingMessage() {
             if (isGameOver) return resultTextDisplay.textContent;
             if (isGamePaused) return '一時停止中... 「スタート」で再開します。';
             if (currentRound === 0 && isGamePaused) return '「スタート」を押してゲームを開始してください。';
             if (gameMode === 'player-vs-ai') return 'あなたの手を選んでください。';
             if (gameMode === 'player-vs-player') {
                 const turnPlayerName = (currentPlayerTurn === 'player1') ?
                                        playerNameDisplay.textContent.split(':')[0].trim() :
                                        aiNameDisplay.textContent.split(':')[0].trim();
                 return `${turnPlayerName}の手を待っています...`;
             }
             if (gameMode === 'ai-vs-ai') return '対戦中...';
             return '結果を待っています...';
         }

        function updateHandDisplays(hand1, hand2) {
             playerHandDisplay.style.opacity = 0; aiHandDisplay.style.opacity = 0;
             playerHandDisplay.textContent = HAND_EMOJIS[hand1] || '?';
             aiHandDisplay.textContent = HAND_EMOJIS[hand2] || '?';
             void playerHandDisplay.offsetWidth; void aiHandDisplay.offsetWidth;
             playerHandDisplay.classList.add('fade-in'); aiHandDisplay.classList.add('fade-in');
             playerHandDisplay.addEventListener('animationend', () => playerHandDisplay.classList.remove('fade-in'), { once: true });
             aiHandDisplay.addEventListener('animationend', () => aiHandDisplay.classList.remove('fade-in'), { once: true });
        }
         function resetHandDisplays() {
             clearTimeout(roundResetTimeoutId);
             playerHandDisplay.classList.remove('fade-in'); aiHandDisplay.classList.remove('fade-in');
             playerHandDisplay.style.opacity = 1; aiHandDisplay.style.opacity = 1;
             playerHandDisplay.textContent = '?'; aiHandDisplay.textContent = '?';
         }
         function enablePlayerChoices(enable) {
             playerChoiceButtons.forEach(button => { button.disabled = !enable; });
         }


        function initializeResultsChart() {
            if (resultsChartInstance) resultsChartInstance.destroy();
            const ctx = document.getElementById('resultsChart').getContext('2d');
            const colors = getChartColors();
            let p1Label = 'あなたの勝ち数', p2Label = 'AIの勝ち数';
             if (gameMode === 'ai-vs-ai') { p1Label = 'AI 1の勝ち数'; p2Label = 'AI 2の勝ち数'; }
             else if (gameMode === 'player-vs-player') { p1Label = 'あなたの勝ち数'; p2Label = 'ユーザー2の勝ち数'; }
             const diffLabel = 'スコア差';
            resultsChartData = {
                labels: [0],
                datasets: [
                    { label: p1Label, data: [0], borderColor: colors.accent1, tension: 0, fill: false, yAxisID: 'y' },
                    { label: p2Label, data: [0], borderColor: colors.accent2, tension: 0, fill: false, yAxisID: 'y' },
                    { label: 'あいこ', data: [0], borderColor: colors.accent3, tension: 0, fill: false, yAxisID: 'y' },
                    { label: diffLabel, data: [0], borderColor: colors.accent4, tension: 0, fill: false, borderDash: [5, 5], yAxisID: 'y1' }
                ]
            };
            if(resultsZoomToggleSwitch) resultsZoomToggleSwitch.checked = isResultsZoomEnabled;
            resultsChartInstance = new Chart(ctx, {
                type: 'line', data: resultsChartData,
                options: {
                    responsive: true, maintainAspectRatio: false,
                    animation: { duration: gameMode === 'ai-vs-ai' ? 0 : 200 },
                    scales: {
                         y: { type: 'linear', display: true, position: 'left', grid: { color: colors.gridColor }, ticks: { color: colors.labelColor, callback: value => formatNumber(value), beginAtZero: true }, grace: '10%', title: { display: true, text: '累計スコア', color: colors.titleColor } },
                        y1: { type: 'linear', display: true, position: 'right', grid: { drawOnChartArea: false }, ticks: { color: colors.labelColor, callback: value => formatNumber(value) }, grace: '10%', title: { display: true, text: diffLabel, color: colors.titleColor } },
                        x: { grid: { color: colors.gridColor }, ticks: { color: colors.labelColor, callback: function(value) { const label = this.getLabelForValue(value); if (typeof label === 'number' && label % 1 === 0) { return formatNumber(label); } return formatNumber(label); }, maxTicksLimit: 15, autoSkip: true }, title: { display: true, text: 'ラウンド数', color: colors.titleColor } }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: colors.labelColor } },
                        title: { display: true, text: '勝負の推移', color: colors.titleColor, font: { size: 16 } },
                        zoom: { pan: { enabled: isResultsZoomEnabled, mode: 'xy', threshold: 5 }, zoom: { wheel: { enabled: isResultsZoomEnabled }, pinch: { enabled: isResultsZoomEnabled }, mode: 'xy', drag: { enabled: false } } }
                    },
                    elements: { point:{ radius: 0 }, line: { borderWidth: 2 } },
                    interaction: { mode: 'index', intersect: false }, hover: { mode: 'nearest', intersect: false }
                }
            });
            updateChartColors(resultsChartInstance);
        }

        function initializeHandsBarChart() { // <<< RENAMED and MODIFIED for Bar Chart
            if (handsChartInstance) handsChartInstance.destroy();
            const ctx = document.getElementById('handsChart').getContext('2d');
            const colors = getChartColors();

            let p1Name = playerNameDisplay.textContent.split(':')[0].trim() || 'Player 1';
            let p2Name = aiNameDisplay.textContent.split(':')[0].trim() || 'Player 2';

            const initialP1Data = [scores.player1Hands.rock, scores.player1Hands.paper, scores.player1Hands.scissors];
            const initialP2Data = [scores.player2Hands.rock, scores.player2Hands.paper, scores.player2Hands.scissors];

            // Bar chart data structure
            const data = {
                labels: HAND_EMOJIS_ARRAY, // ['✊', '✋', '✌️']
                datasets: [
                    {
                        label: p1Name,
                        data: initialP1Data,
                        backgroundColor: colors.accent1, // Use accent1 for P1 bars
                        borderColor: colors.accent1,
                        borderWidth: 1
                    },
                    {
                        label: p2Name,
                        data: initialP2Data,
                        backgroundColor: colors.accent2, // Use accent2 for P2 bars
                        borderColor: colors.accent2,
                        borderWidth: 1
                    }
                ]
            };

             if(handsZoomToggleSwitch) handsZoomToggleSwitch.checked = isHandsZoomEnabled; // Still set, though zoom is less useful
            handsChartInstance = new Chart(ctx, {
                type: 'bar', // <<< CHANGED to 'bar'
                data: data,
                options: {
                    responsive: true, maintainAspectRatio: false,
                    animation: { duration: 200 }, // Animation for bar updates
                    scales: {
                         y: {
                            beginAtZero: true,
                            grid: { color: colors.gridColor },
                            ticks: { color: colors.labelColor, stepSize: 1, callback: value => formatNumber(value) }, // Ensure integer ticks
                            title: { display: true, text: '選択回数', color: colors.titleColor }
                         },
                        x: { // X-axis shows hands (Rock, Paper, Scissors)
                            grid: { color: colors.gridColor },
                            ticks: { color: colors.labelColor }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: colors.labelColor } },
                        title: { display: true, text: '各手の合計選択回数', color: colors.titleColor, font: { size: 16 } },
                        zoom: { // Zoom might not be very useful for a fixed bar chart
                            pan: { enabled: isHandsZoomEnabled, mode: 'y', threshold: 5 }, // Pan Y only
                            zoom: { wheel: { enabled: isHandsZoomEnabled, mode: 'y' }, pinch: { enabled: isHandsZoomEnabled, mode: 'y' }, drag: { enabled: false } }
                        }
                    },
                    indexAxis: 'x', // Bars are vertical (categories on x-axis)
                }
            });
            updateChartColors(handsChartInstance, true); // Pass isBarChart = true
        }


        function resetZoom(chartId) {
            if (chartId === 'resultsChart' && resultsChartInstance) resultsChartInstance.resetZoom();
            if (chartId === 'handsChart' && handsChartInstance) handsChartInstance.resetZoom();
        }
        function toggleZoomSwitch(isChecked, chartId) {
            if (chartId === 'resultsChart') {
                isResultsZoomEnabled = isChecked;
                enableZoom(resultsChartInstance, isResultsZoomEnabled);
            } else if (chartId === 'handsChart') {
                isHandsZoomEnabled = isChecked;
                enableZoom(handsChartInstance, isHandsZoomEnabled, true); // Pass isBarChart for Y-axis only zoom
            }
        }
        function enableZoom(chart, enable, isBarChart = false) {
            if (!chart) return;
            const zoomMode = isBarChart ? 'y' : 'xy';
            chart.options.plugins.zoom.zoom.wheel.enabled = enable;
            chart.options.plugins.zoom.zoom.wheel.mode = zoomMode;
            chart.options.plugins.zoom.zoom.pinch.enabled = enable;
            chart.options.plugins.zoom.zoom.pinch.mode = zoomMode;
            chart.options.plugins.zoom.pan.enabled = enable;
            chart.options.plugins.zoom.pan.mode = zoomMode;
            chart.update('none');
        }

        function updateResultsChart() {
            if (!resultsChartInstance || !resultsChartData) return;
            const scoreDiff = scores.player1 - scores.player2;
            resultsChartData.labels.push(currentRound);
            resultsChartData.datasets[0].data.push(scores.player1);
            resultsChartData.datasets[1].data.push(scores.player2);
            resultsChartData.datasets[2].data.push(scores.draw);
            resultsChartData.datasets[3].data.push(scoreDiff);
            const MAX_CHART_POINTS = 200;
            if (resultsChartData.labels.length > MAX_CHART_POINTS) {
                const shiftAmount = resultsChartData.labels.length - MAX_CHART_POINTS;
                resultsChartData.labels.splice(0, shiftAmount);
                resultsChartData.datasets.forEach(dataset => dataset.data.splice(0, shiftAmount));
            }
            resultsChartInstance.update('none');
        }

        function updateHandsBarChart() { // <<< RENAMED and MODIFIED for Bar Chart
            if (!handsChartInstance) return;

            handsChartInstance.data.datasets[0].data = [
                scores.player1Hands.rock,
                scores.player1Hands.paper,
                scores.player1Hands.scissors
            ];
            handsChartInstance.data.datasets[1].data = [
                scores.player2Hands.rock,
                scores.player2Hands.paper,
                scores.player2Hands.scissors
            ];
            handsChartInstance.update(); // Use default animation or 'none' if preferred
        }


        function showNotification(message, showConfirm = false, isSuccess = false, autoHideDelay = 4000) {
            if (notificationTimeoutId) { clearTimeout(notificationTimeoutId); notificationTimeoutId = null; }
            if (isNotificationVisible) {
                notificationArea.style.opacity = 0;
                 setTimeout(() => { _displayNotification(message, showConfirm, isSuccess, autoHideDelay); }, 150);
            } else { _displayNotification(message, showConfirm, isSuccess, autoHideDelay); }
        }
        function _displayNotification(message, showConfirm, isSuccess, autoHideDelay){
             isNotificationVisible = false; notificationMessage.textContent = message;
             notificationArea.style.display = 'block'; notificationArea.style.opacity = 0;
             void notificationArea.offsetWidth; notificationArea.classList.add('fade-in');
             isNotificationVisible = true;
             if (!showConfirm && autoHideDelay > 0) {
                 notificationTimeoutId = setTimeout(() => {
                      if (isNotificationVisible) { hideNotification(); } notificationTimeoutId = null;
                 }, autoHideDelay);
             }
        }
        function hideNotification(immediately = false) {
            if (!isNotificationVisible) return;
            if (notificationTimeoutId) { clearTimeout(notificationTimeoutId); notificationTimeoutId = null; }
            isNotificationVisible = false;
            if (immediately) {
                 notificationArea.style.opacity = 0; notificationArea.style.display = 'none';
                 notificationArea.classList.remove('fade-in');
            } else {
                notificationArea.style.opacity = 0;
                setTimeout(() => {
                    if (!isNotificationVisible) {
                         notificationArea.style.display = 'none'; notificationArea.classList.remove('fade-in');
                    }
                }, 300);
            }
        }

         function resetScoresAndHistories() {
             scores = {
                player1: 0, player2: 0, draw: 0,
                player1Hands: { rock: 0, paper: 0, scissors: 0 },
                player2Hands: { rock: 0, paper: 0, scissors: 0 }
            };
             ai1History = []; ai2History = [];
         }
         function resetGameFullState() {
             resetScoresAndHistories();
             currentRound = 0; isGameOver = false; isGamePaused = true; isAiVsAiRunning = false;
             currentPlayerTurn = 'player1'; player1HandChoice = null;
             clearTimeout(roundResetTimeoutId); clearTimeout(notificationTimeoutId);
             clearInterval(aiVsAiIntervalId); aiVsAiIntervalId = null;
         }

        function saveGameData() {
             if (gameMode === 'player-vs-ai') {
                 try {
                    const MAX_SAVE_HISTORY = 1000;
                    const historyToSave = playerHistory.slice(-MAX_SAVE_HISTORY);
                    localStorage.setItem('rpsGameData', JSON.stringify({ playerHistory: historyToSave }));
                 } catch (e) { console.error("Error saving game data:", e); }
             }
        }
        function loadGameData() {
             try {
                const savedData = localStorage.getItem('rpsGameData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    const MAX_LOAD_HISTORY = 1000;
                    playerHistory = Array.isArray(parsedData.playerHistory) ? parsedData.playerHistory.slice(-MAX_LOAD_HISTORY) : [];
                } else { playerHistory = []; }
             } catch (e) { console.error("Error loading game data:", e); playerHistory = []; }
        }

        function formatNumber(num) {
            if (typeof num !== 'number' || !isFinite(num)) {
                if (num === Infinity) return '∞'; if (isNaN(num)) return '?'; return num ? String(num) : '0';
            }
            const sign = num < 0 ? '-' : ''; let absNum = Math.abs(num);
            const googol = 1e100;
            if (absNum >= googol) {
                 let unitKey = null; for (const key of UNIT_KEYS.reverse()) { if (absNum >= Math.pow(10, key)) { unitKey = key; break; } } UNIT_KEYS.reverse();
                 if (unitKey) { const value = absNum / Math.pow(10, unitKey); return sign + value.toFixed(2).replace(/(\.0+|(?<=\.\d)0+)$/, '') + UNITS[unitKey]; }
                 else { return sign + absNum.toExponential(2); }
            }
            for (const key of UNIT_KEYS) {
                const threshold = Math.pow(10, key);
                if (absNum >= threshold) {
                    const value = absNum / threshold; let formattedNum;
                    if (value < 10) { formattedNum = value.toFixed(2); } else if (value < 100) { formattedNum = value.toFixed(1); } else { formattedNum = value.toFixed(0); }
                    formattedNum = formattedNum.replace(/(\.0+|(?<=\.\d)0+)$/, ''); return sign + formattedNum + UNITS[key];
                }
            }
             if (absNum < 1000) { return sign + absNum.toString(); } return sign + absNum.toString();
        }


        function fadeInElement(element) {
            if (!element) return;
            const computedStyle = getComputedStyle(element); const currentOpacity = parseFloat(computedStyle.opacity); const isDisplayed = computedStyle.display !== 'none';
            if (isDisplayed && currentOpacity === 1 && !element.classList.contains('fade-in')) { element.classList.remove('initially-hidden'); return; }
            if (isDisplayed && currentOpacity > 0 && currentOpacity < 1 && computedStyle.animationName && computedStyle.animationName.includes('fadeIn') && !element.classList.contains('initially-hidden-triggered-by-js')) { return; }
            element.classList.remove('initially-hidden'); element.classList.add('initially-hidden-triggered-by-js');
            
            let displayStyle = 'block';
            if (element.classList.contains('zoom-controls') || element.id === 'player-controls' || element.id === 'ai-vs-ai-controls') {
                displayStyle = 'flex';
            } else if (element.id === 'hands-stats') {
                displayStyle = 'grid';
            }
            element.style.display = displayStyle;

            if (element.classList.contains('fade-in')) { element.classList.remove('fade-in'); void element.offsetWidth; }
            element.style.opacity = 0; void element.offsetWidth; element.classList.add('fade-in');
            element.addEventListener('animationend', function handler() {
                element.classList.remove('fade-in'); element.style.opacity = 1; element.classList.remove('initially-hidden-triggered-by-js');
            }, { once: true });
            setTimeout(() => {
                if (element.classList.contains('fade-in')) { element.classList.remove('fade-in'); element.style.opacity = 1; }
                else if (getComputedStyle(element).display !== 'none' && parseFloat(getComputedStyle(element).opacity) < 1) { element.style.opacity = 1; }
                element.classList.remove('initially-hidden-triggered-by-js');
            }, 550);
        }
        function hideElement(element) {
            if (!element) return; if (element.style.display === 'none') return;
            element.style.opacity = 0; element.classList.remove('fade-in'); element.classList.remove('initially-hidden-triggered-by-js');
            setTimeout(() => { if (element.style.opacity === '0') { element.style.display = 'none'; } }, 300);
        }
         function fadeInElementText(element, text) {
             if (!element) return;
             const isVisible = element.style.display !== 'none' && element.style.opacity !== '0';
             if (element.textContent === text && isVisible) return;
             if (isVisible) {
                 element.style.transition = 'opacity 0.15s ease-out'; element.style.opacity = 0;
                 setTimeout(() => {
                     element.textContent = text; if (element.style.display === 'none') element.style.display = ''; element.style.opacity = 1;
                     setTimeout(() => element.style.transition = '', 150);
                 }, 150);
             } else {
                 element.textContent = text; if (element.style.display === 'none') { element.style.opacity = 0; }
             }
         }
    </script>
</body>
</html>
