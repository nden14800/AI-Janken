<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>じゃんけんAI</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Google Sans から Roboto に変更 -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Color Variables --- */
        :root {
            --bg-color: #f0f0f0;
            --text-color: #333;
            --container-bg: #fff;
            --container-shadow: rgba(0,0,0,0.1);
            --border-color: #eee;
            --button-bg: #4285F4;
            --button-text: white;
            --button-hover-bg: #357ae8;
            --button-disabled-bg: #ccc;
            --button-disabled-text: #666;
            --secondary-text-color: #555;
            --chart-grid-color: rgba(0, 0, 0, 0.1);
            --chart-label-color: #666;
            --chart-title-color: #333;
            --notification-bg: rgba(0, 0, 0, 0.8);
            --notification-text: white;
            --notification-button-bg: #555;
            --notification-button-hover-bg: #777;
            --danger-button-bg: #f44336;
            --danger-button-hover-bg: #d32f2f;
            --warning-button-bg: #ff9800; /* Added for Pause */
            --warning-button-hover-bg: #fb8c00; /* Added for Pause */
            --accent1-color: rgb(75, 192, 192); /* Player 1 / You */
            --accent2-color: rgb(255, 99, 132); /* Player 2 / AI / User 2 */
            --accent3-color: rgb(201, 203, 207); /* Draw */
            --accent4-color: rgb(153, 102, 255); /* Score Difference */
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #e0e0e0;
                --container-bg: #1e1e1e;
                --container-shadow: rgba(255, 255, 255, 0.1);
                --border-color: #333;
                --button-bg: #5c8fef;
                --button-text: #121212;
                --button-hover-bg: #7faaf0;
                --button-disabled-bg: #444;
                --button-disabled-text: #888;
                --secondary-text-color: #aaa;
                --chart-grid-color: rgba(255, 255, 255, 0.1);
                --chart-label-color: #aaa;
                --chart-title-color: #e0e0e0;
                --notification-bg: rgba(230, 230, 230, 0.9);
                --notification-text: #121212;
                --notification-button-bg: #bbb;
                --notification-button-hover-bg: #ccc;
                --danger-button-bg: #ef5350;
                --danger-button-hover-bg: #e57373;
                --warning-button-bg: #ffa726; /* Added for Pause */
                --warning-button-hover-bg: #ffb74d; /* Added for Pause */
                /* Keep accent colors */
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            animation: fadeIn 0.5s ease-out; /* Body itself fades in */
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            background-color: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px var(--container-shadow);
            width: 100%;
            max-width: 900px;
            box-sizing: border-box;
            opacity: 0; /* Initial state for CSS animation */
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 0.2s; /* Container fades in after body */
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* General style for elements that will have delayed CSS fade-in */
        h1, h2, h3, p, button, label, span, div, input, select, 
        #scoreboard div, #game-display div, 
        #player-controls button, #ai-vs-ai-controls > div, #ai-vs-ai-controls button, 
        #chart-container, #round-info, #result-text, #turn-indicator, 
        .zoom-controls button, .zoom-controls span {
            font-family: 'Roboto', sans-serif;
            color: var(--text-color);
            /* animation and opacity are set individually or by fadeInElement for dynamic ones */
            transition: color 0.3s ease, background-color 0.3s ease;
        }
        
        /* Elements that are part of initial layout and fade in with CSS delays */
        .container > h1, .container > #mode-selection > h2, .container > #mode-selection .mode-buttons button,
        .container > #game-length-selection > h2, .container > #game-length-selection #game-length-buttons button,
        #scoreboard > div, /* Scoreboard items */
        #game-display > .player-area > div, #game-display > .ai-area > div, #game-display > div[style*="font-size: 1.5em"], /* VS text */
        #round-info, #result-text, /* These are initially populated or cleared by JS */
        #chart-container > canvas, /* Canvas itself may not need this if parent chart-container fades */
        .zoom-controls > button, .zoom-controls > span /* Zoom controls parts */
        {
            opacity: 0; /* Start transparent for CSS animation */
            animation: fadeIn 0.6s ease-out forwards; /* Apply CSS animation */
        }


         button { color: var(--button-text); }
         button:disabled { color: var(--button-disabled-text); }
         #round-info, #ai-speed-display, .player-area div, .ai-area div, label, #ai-vs-ai-controls span, .zoom-controls span, #player-controls label {
            color: var(--secondary-text-color);
            transition: color 0.3s ease;
         }
         #result-text, #turn-indicator, #score-difference-display { color: var(--text-color); transition: color 0.3s ease;}
         #player-score-display, #ai-score-display, #draw-score-display { font-weight: bold; transition: color 0.3s ease;}
         #score-difference-display { font-weight: normal; transition: color 0.3s ease;}

        /* Animation delays for initial page load elements */
        .container > h1 { animation-delay: 0.3s; }
        .container > #mode-selection > h2 { animation-delay: 0.4s; }
        /* mode-selection buttons need individual delays if desired, or use a wrapper */
        #mode-selection .mode-buttons button:nth-child(1) { animation-delay: 0.5s; }
        #mode-selection .mode-buttons button:nth-child(2) { animation-delay: 0.55s; }
        #mode-selection .mode-buttons button:nth-child(3) { animation-delay: 0.6s; }
        
        /* Game length buttons: these are shown later by JS, so fadeInElement will handle them */
        /* Scoreboard items: shown by JS (fadeInElement on gameAreaDiv), then these fade by CSS */
        #scoreboard div:nth-child(1) { animation-delay: 0.6s; }
        #scoreboard div:nth-child(2) { animation-delay: 0.65s; }
        #scoreboard div:nth-child(3) { animation-delay: 0.7s; }
        #score-difference-display { animation-delay: 0.75s; } /* This is part of scoreboard */

        /* Game display elements */
        #game-display > .player-area > div:first-child { animation-delay: 0.6s; } /* Player Name */
        #game-display > .player-area > .hand-display { animation-delay: 0.65s; } /* Player Hand - may be overridden by JS */
        #game-display > div[style*="font-size: 1.5em"] { animation-delay: 0.7s; } /* VS */
        #game-display > .ai-area > div:first-child { animation-delay: 0.75s; } /* AI Name */
        #game-display > .ai-area > .hand-display { animation-delay: 0.8s; } /* AI Hand - may be overridden by JS */
        
        #round-info { animation-delay: 0.85s; }
        /* result-text is typically updated by JS, so initial animation might not be very visible or needed here if cleared quickly */
        /* turn-indicator is initially-hidden, so JS handles it */

        /* Chart and zoom controls are shown later by JS (fadeInElement) */
        /* Their internal parts might have delays relative to their container's fadeInElement */


        .fade-in { /* This class is added by JavaScript for dynamic fade-ins */
            animation: fadeIn 0.5s ease-out forwards !important; /* Ensure JS animation takes precedence */
            opacity: 0; /* Start state for JS animation */
        }

        .initially-hidden {
            display: none;
            opacity: 0;
        }

        button {
            font-size: 1em;
            padding: 10px 15px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--button-bg);
            color: var(--button-text);
            transition: background-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
        }
        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
        }
        button:disabled {
            background-color: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            cursor: not-allowed;
            opacity: 0.7;
        }
        #quit-button, #ai-quit-button {
             background-color: var(--danger-button-bg);
        }
         #quit-button:hover:not(:disabled), #ai-quit-button:hover:not(:disabled) {
             background-color: var(--danger-button-hover-bg);
         }
         #start-pause-button.paused, #ai-vs-ai-start-stop.paused {
            background-color: var(--warning-button-bg);
         }
         #start-pause-button.paused:hover:not(:disabled), #ai-vs-ai-start-stop.paused:hover:not(:disabled) {
            background-color: var(--warning-button-hover-bg);
         }


        .mode-buttons button, #game-length-buttons button {
             min-width: 80px;
             margin-bottom: 10px;
        }

        #game-area {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
             transition: border-color 0.3s ease;
        }

        #scoreboard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            text-align: center;
        }
        /* #scoreboard div animation-delay is set above */
        #score-difference-display {
            grid-column: 1 / -1;
            margin-top: 10px;
            font-size: 1em;
            color: var(--secondary-text-color);
        }

        #game-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 30px;
            min-height: 100px;
        }

        .player-area, .ai-area {
            text-align: center;
        }

        .hand-display {
            font-size: 3em;
            min-width: 60px;
            min-height: 60px;
            display: inline-block;
            line-height: 60px;
            /* opacity: 1; by default, JS or CSS will handle fade-in */
            transition: opacity 0.3s ease; /* For reset or quick changes */
        }

        #player-controls, #ai-vs-ai-controls {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #player-controls > div, #ai-vs-ai-controls > div {
             display: flex;
             flex-wrap: wrap;
             justify-content: center;
             align-items: center;
             gap: 10px;
        }
        #ai-vs-ai-controls label, #ai-vs-ai-controls input, #ai-vs-ai-controls span { color: var(--secondary-text-color); transition: color 0.3s ease;}
        #turn-indicator {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            min-height: 1.2em;
            transition: color 0.3s ease;
        }

        #chart-container {
            width: 100%;
            max-width: 100%;
            height: 450px;
            margin: 30px auto 20px auto;
            background-color: var(--container-bg);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px var(--container-shadow);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            /* display: block; will be handled by JS initially-hidden */
        }
        #resultsChart {
            width: 100% !important;
            height: 100% !important;
        }

        #notification-area {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--notification-bg);
            color: var(--notification-text);
            padding: 15px 30px;
            border-radius: 5px;
            z-index: 1000;
            text-align: center;
            opacity: 0;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
            cursor: pointer;
        }
        #notification-area.fade-in { /* This class is added by JS */
             display: block; /* Show before animating opacity */
             animation: fadeIn 0.5s ease-out forwards;
        }
        #notification-area button {
            background-color: var(--notification-button-bg);
            color: var(--notification-text);
            margin-top: 10px;
             transition: background-color 0.3s ease;
        }
         #notification-area button:hover {
            background-color: var(--notification-button-hover-bg);
        }
        #notification-message {
            margin-bottom: 10px;
            opacity: 1; /* Text within notification is always opaque relative to its container */
            animation: none; /* No separate animation for this p tag */
            color: var(--notification-text);
            transition: color 0.3s ease;
        }

        #ai-speed-slider {
            width: 200px;
            margin: 0 10px;
            cursor: pointer;
            accent-color: var(--button-bg);
        }

        .result-text {
            font-weight: bold;
            margin-top: 10px;
            font-size: 1.2em;
            color: var(--text-color);
            transition: color 0.3s ease;
            min-height: 1.5em;
        }

        #player-hand, #ai-hand {
             opacity: 1; /* Default opacity, JS handles fade-in for updates */
        }

        input[type=range] {
          -webkit-appearance: none; appearance: none;
          width: 200px; height: 8px; background: var(--border-color);
          outline: none; border-radius: 4px; transition: background 0.3s ease;
          vertical-align: middle;
        }
        input[type=range]::-webkit-slider-thumb {
          -webkit-appearance: none; appearance: none;
          width: 20px; height: 20px; background: var(--button-bg);
          cursor: pointer; border-radius: 50%; transition: background 0.3s ease;
        }
        input[type=range]::-moz-range-thumb {
          width: 20px; height: 20px; background: var(--button-bg);
          cursor: pointer; border-radius: 50%; border: none; transition: background 0.3s ease;
        }
         input[type=range]::-moz-range-track {
            background: var(--border-color); height: 8px; border-radius: 4px; transition: background 0.3s ease;
         }

        /* --- Switch Styles --- */
        .switch {
          position: relative;
          display: inline-block;
          width: 44px;
          height: 24px;
          vertical-align: middle;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
          position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
          background-color: #ccc; transition: .4s;
        }
        .slider:before {
          position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
          background-color: white; transition: .4s;
        }
        input:checked + .slider { background-color: var(--button-bg); }
        input:focus + .slider { box-shadow: 0 0 1px var(--button-bg); }
        input:checked + .slider:before { transform: translateX(20px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }
        /* --- End Switch Styles --- */

        /* Adjust layout for zoom controls */
        .zoom-controls {
            /* opacity: 0; handled by initially-hidden and fadeInElement */
            /* animation: fadeIn 0.6s ease-out forwards; handled by fadeInElement */
            /* animation-delay: 1.0s; */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        .zoom-controls > span {
            display: inline-flex;
            align-items: center;
        }
         .zoom-controls span label, .zoom-controls span span {
             color: var(--secondary-text-color);
             transition: color 0.3s ease;
             vertical-align: middle;
             margin-left: 5px;
         }
    </style>
</head>
<body>
    <div class="container">
        <h1>じゃんけんAI</h1>

        <div id="mode-selection">
            <h2>モード選択</h2>
            <div class="mode-buttons">
                <button onclick="selectMode('player-vs-ai')">あなた VS AI</button>
                <button onclick="selectMode('ai-vs-ai')">AI VS AI</button>
                <button onclick="selectMode('player-vs-player')">あなた VS ユーザー2</button>
            </div>
        </div>

        <div id="game-length-selection" class="initially-hidden">
            <h2>勝負回数選択</h2>
            <div id="game-length-buttons">
                <button onclick="setGameLength(1)">1回勝負</button>
                <button onclick="setGameLength(5)">5回勝負</button>
                <button onclick="setGameLength(10)">10回勝負</button>
                <button onclick="setGameLength(25)">25回勝負</button>
                <button onclick="setGameLength(50)">50回勝負</button>
                <button onclick="setGameLength(100)">100回勝負</button>
                <button onclick="setGameLength(250)">250回勝負</button>
                <button onclick="setGameLength(500)">500回勝負</button>
                <button onclick="setGameLength(1000)">1,000回勝負</button>
                <button onclick="setGameLength(Infinity)">∞</button>
            </div>
        </div>

        <div id="game-area" class="initially-hidden">
            <div id="scoreboard">
                 <div id="player-score-display">あなた: 0</div>
                 <div id="draw-score-display">あいこ: 0</div>
                 <div id="ai-score-display">AI: 0</div>
                 <div id="score-difference-display">同点</div>
            </div>
             <div id="round-info" style="text-align: center; margin-bottom: 15px; font-size: 0.9em;">ラウンド: 0 / 0</div>

            <div id="game-display">
                <div class="player-area">
                    <div id="player-name">あなた</div>
                    <div id="player-hand" class="hand-display">?</div>
                </div>
                <div style="font-size: 1.5em; font-weight: bold;">VS</div>
                <div class="ai-area">
                     <div id="ai-name">AI</div>
                    <div id="ai-hand" class="hand-display">?</div>
                </div>
            </div>

             <div id="result-text" class="result-text" style="text-align: center;">結果を待っています...</div>
             <div id="turn-indicator" style="text-align: center;" class="initially-hidden"></div>


            <div id="player-controls" class="initially-hidden">
                 <div>
                    <h3 id="player-controls-title" style="margin: 0 10px 0 0; animation: none; opacity: 1;">あなたの手を選択してください:</h3>
                    <button onclick="playerChoose('rock')">✊ グー</button>
                    <button onclick="playerChoose('paper')">✋ パー</button>
                    <button onclick="playerChoose('scissors')">✌️ チョキ</button>
                 </div>
                 <div>
                    <button id="start-pause-button" onclick="toggleStartPause()">スタート</button>
                    <button id="quit-button" onclick="quitGame()">辞める</button>
                 </div>
            </div>

            <div id="ai-vs-ai-controls" class="initially-hidden">
                <div>
                    <label for="ai-speed-slider" style="animation: none; opacity: 1;">対戦速度 (回/秒):</label>
                    <input type="range" id="ai-speed-slider" min="1" max="200" value="10" oninput="updateSpeedDisplay(this.value)" style="animation: none; opacity: 1;">
                    <span id="ai-speed-display" style="animation: none; opacity: 1;">10</span> <span style="animation: none; opacity: 1;">回/秒</span>
                </div>
                <div>
                    <button id="ai-vs-ai-start-stop" onclick="toggleStartPause()">スタート</button>
                    <button id="ai-quit-button" onclick="quitGame()">辞める</button>
                </div>
            </div>

        </div>

        <div id="chart-container" class="initially-hidden">
            <canvas id="resultsChart"></canvas>
            <div class="zoom-controls initially-hidden">
                <button onclick="resetZoom()" id="reset-zoom-button">ズームリセット</button>
                <span>
                    <label class="switch" style="animation: none; opacity: 1;">
                        <input type="checkbox" id="zoom-toggle-switch" onchange="toggleZoomSwitch(this.checked)" checked>
                        <span class="slider round"></span>
                    </label>
                    <span style="animation: none; opacity: 1;">ズーム有効</span>
                </span>
            </div>
        </div>

    </div>

    <div id="notification-area" onclick="hideNotification()">
        <p id="notification-message">メッセージ</p>
    </div>

    <script>
        // Chart.js のデフォルトフォントを設定 (Google Sans から Roboto に変更)
        Chart.defaults.font.family = "'Roboto', sans-serif";

        const HANDS = ['rock', 'paper', 'scissors'];
        const HAND_EMOJIS = { rock: '✊', paper: '✋', scissors: '✌️' };
        const WIN_CONDITIONS = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
        const UNITS = {
             3: 'K',  6: 'M',  9: 'B', 12: 'T', 15: 'Q', 18: 'Qu', 21: 'Sx', 24: 'Sp',
            27: 'O', 30: 'N', 33: 'D', 36: 'Ud', 39: 'Duo', 42: 'Tre', 45: 'Qua',
            48: 'Qd', 51: 'Sd', 54: 'Sepd', 57: 'Oct', 60: 'NV', 63: 'V', 66: 'UNV',
            69: 'A', 72: 'C', 75: 'E', 78: 'F', 81: 'G', 84: 'H', 87: 'I', 90: 'J',
            93: 'L', 96: 'P'
        };
        const UNIT_KEYS = Object.keys(UNITS).map(Number).sort((a, b) => b - a);


        let gameMode = '';
        let currentGameLength = 0;
        let currentRound = 0;
        let scores = { player1: 0, player2: 0, draw: 0 };
        let playerHistory = [];
        let ai1History = [];
        let ai2History = [];
        let chartInstance = null;
        let chartData = { labels: [], datasets: [] };
        let aiVsAiIntervalId = null;
        let aiVsAiSpeed = 10;
        let isAiVsAiRunning = false;
        let isGameOver = false;
        let isGamePaused = true;
        let colorSchemeMatcher = window.matchMedia('(prefers-color-scheme: dark)');
        let notificationTimeoutId = null;
        let isNotificationVisible = false;
        let currentPlayerTurn = 'player1';
        let player1HandChoice = null;
        let roundResetTimeoutId = null;
        let isZoomEnabled = true;

        const modeSelectionDiv = document.getElementById('mode-selection');
        const gameLengthSelectionDiv = document.getElementById('game-length-selection');
        const gameAreaDiv = document.getElementById('game-area');
        const scoreboardPlayerDisplay = document.getElementById('player-score-display');
        const scoreboardDrawDisplay = document.getElementById('draw-score-display');
        const scoreboardAiDisplay = document.getElementById('ai-score-display');
        const scoreDifferenceDisplay = document.getElementById('score-difference-display');
        const roundInfoDisplay = document.getElementById('round-info');
        const playerNameDisplay = document.getElementById('player-name');
        const aiNameDisplay = document.getElementById('ai-name');
        const playerHandDisplay = document.getElementById('player-hand');
        const aiHandDisplay = document.getElementById('ai-hand');
        const resultTextDisplay = document.getElementById('result-text');
        const turnIndicator = document.getElementById('turn-indicator');
        const playerControlsDiv = document.getElementById('player-controls');
        const playerControlsTitle = document.getElementById('player-controls-title');
        const aiVsAiControlsDiv = document.getElementById('ai-vs-ai-controls');
        const aiSpeedSlider = document.getElementById('ai-speed-slider');
        const aiSpeedDisplay = document.getElementById('ai-speed-display');
        const startPauseButton = document.getElementById('start-pause-button');
        const aiVsAiStartStopButton = document.getElementById('ai-vs-ai-start-stop');
        const chartContainerDiv = document.getElementById('chart-container');
        const notificationArea = document.getElementById('notification-area');
        const notificationMessage = document.getElementById('notification-message');
        const quitButton = document.getElementById('quit-button');
        const aiQuitButton = document.getElementById('ai-quit-button');
        const gameLengthButtons = document.getElementById('game-length-buttons').querySelectorAll('button');
        const playerChoiceButtons = playerControlsDiv.querySelectorAll('button:not(#start-pause-button):not(#quit-button)');
        const resetZoomButton = document.getElementById('reset-zoom-button');
        const zoomToggleSwitch = document.getElementById('zoom-toggle-switch');
        const zoomControlsDiv = document.querySelector('.zoom-controls');

        window.onload = () => {
            loadGameData();
            colorSchemeMatcher.addEventListener('change', handleColorSchemeChange);
            updateScoreboard();
            resetHandDisplays();
            isGamePaused = true;
            hideElement(playerControlsDiv);
            hideElement(aiVsAiControlsDiv);
            // Remove opacity and animation from elements that JS will control more directly or that don't need initial fade
            // This helps prevent conflicts between CSS initial animations and JS dynamic animations
            const noJsInitialFade = [
                playerControlsTitle, aiSpeedSlider, aiSpeedDisplay,
                document.querySelector('#ai-vs-ai-controls label[for="ai-speed-slider"]'),
                document.querySelector('#ai-vs-ai-controls span:last-of-type'), // "回/秒" text
                document.querySelector('.zoom-controls .switch'),
                document.querySelector('.zoom-controls span span') // "ズーム有効" text
            ];
            noJsInitialFade.forEach(el => {
                if (el) {
                    el.style.animation = 'none';
                    el.style.opacity = '1';
                }
            });
        };

        function handleColorSchemeChange(e) {
            if (chartInstance) {
                updateChartColors();
                chartInstance.update();
            }
            updateStartPauseButtonState();
        }
        function getChartColors() {
            const style = getComputedStyle(document.documentElement);
            return {
                gridColor: style.getPropertyValue('--chart-grid-color').trim(),
                labelColor: style.getPropertyValue('--chart-label-color').trim(),
                titleColor: style.getPropertyValue('--chart-title-color').trim(),
                accent1: style.getPropertyValue('--accent1-color').trim(),
                accent2: style.getPropertyValue('--accent2-color').trim(),
                accent3: style.getPropertyValue('--accent3-color').trim(),
                accent4: style.getPropertyValue('--accent4-color').trim()
            };
        }
         function updateChartColors() {
             if (!chartInstance) return;
             const colors = getChartColors();
             if (chartInstance.data.datasets[0]) chartInstance.data.datasets[0].borderColor = colors.accent1;
             if (chartInstance.data.datasets[1]) chartInstance.data.datasets[1].borderColor = colors.accent2;
             if (chartInstance.data.datasets[2]) chartInstance.data.datasets[2].borderColor = colors.accent3;
             if (chartInstance.data.datasets[3]) chartInstance.data.datasets[3].borderColor = colors.accent4;
             if (chartInstance.options.scales.x) {
                chartInstance.options.scales.x.grid.color = colors.gridColor;
                chartInstance.options.scales.x.ticks.color = colors.labelColor;
                chartInstance.options.scales.x.title.color = colors.titleColor;
             }
             if (chartInstance.options.scales.y) {
                chartInstance.options.scales.y.grid.color = colors.gridColor;
                chartInstance.options.scales.y.ticks.color = colors.labelColor;
                chartInstance.options.scales.y.title.color = colors.titleColor;
             }
              if (chartInstance.options.scales.y1) {
                 chartInstance.options.scales.y1.grid.color = colors.gridColor;
                 chartInstance.options.scales.y1.ticks.color = colors.labelColor;
                 chartInstance.options.scales.y1.title.color = colors.titleColor;
             }
             if (chartInstance.options.plugins.legend) chartInstance.options.plugins.legend.labels.color = colors.labelColor;
             if (chartInstance.options.plugins.title) chartInstance.options.plugins.title.color = colors.titleColor;
         }

        function selectMode(mode) {
            if (isNotificationVisible) hideNotification(true);
            gameMode = mode;
            hideElement(modeSelectionDiv);
            fadeInElement(gameLengthSelectionDiv);
            let p1Name = 'あなた', p2Name = 'AI';
            if (mode === 'ai-vs-ai') { p1Name = 'AI 1'; p2Name = 'AI 2'; }
            else if (mode === 'player-vs-player') { p1Name = 'あなた'; p2Name = 'ユーザー2'; }
            fadeInElementText(playerNameDisplay, p1Name);
            fadeInElementText(aiNameDisplay, p2Name);
            resetGameFullState();
            fadeInElementText(resultTextDisplay, '勝負回数を選択してください...');
            hideElement(zoomControlsDiv);
        }

        function setGameLength(length) {
            if (isNotificationVisible) hideNotification(true);
            currentGameLength = length;
            resetGameFullState();
            updateScoreboard();
            updateRoundInfo();
            resetHandDisplays();
            hideElement(gameLengthSelectionDiv);
            fadeInElement(gameAreaDiv);
            fadeInElement(chartContainerDiv);
            isZoomEnabled = true;
            initializeChart();
            fadeInElement(zoomControlsDiv);
            zoomToggleSwitch.checked = isZoomEnabled;
            hideElement(playerControlsDiv);
            hideElement(aiVsAiControlsDiv);
            hideElement(turnIndicator);
            isGamePaused = true;
            if (gameMode === 'player-vs-ai' || gameMode === 'player-vs-player') {
                fadeInElement(playerControlsDiv);
                enablePlayerChoices(false);
                fadeInElement(startPauseButton);
                fadeInElement(quitButton);
                if (gameMode === 'player-vs-player') {
                    fadeInElement(turnIndicator);
                }
            } else if (gameMode === 'ai-vs-ai') {
                fadeInElement(aiVsAiControlsDiv);
                aiSpeedSlider.disabled = false;
                fadeInElement(aiVsAiStartStopButton);
                fadeInElement(aiQuitButton);
            }
            updateStartPauseButtonState();
            fadeInElementText(resultTextDisplay, '「スタート」を押してゲームを開始してください。');
        }

        function toggleStartPause() {
            if (isGameOver) return;
            isGamePaused = !isGamePaused;
            clearTimeout(roundResetTimeoutId);
            if (gameMode === 'ai-vs-ai') {
                if (!isGamePaused) { startAiVsAi(); }
                else { stopAiVsAi(); }
            } else {
                if (!isGamePaused) {
                    enablePlayerChoices(true);
                    updateTurnIndicator();
                    fadeInElementText(resultTextDisplay, getWaitingMessage());
                } else {
                    enablePlayerChoices(false);
                    fadeInElementText(resultTextDisplay, '一時停止中... 「スタート」で再開します。');
                    if (gameMode === 'player-vs-player' && currentPlayerTurn === 'player2') {
                        player1HandChoice = null;
                        currentPlayerTurn = 'player1';
                        resetHandDisplays();
                    }
                }
            }
            updateStartPauseButtonState();
        }

        function updateStartPauseButtonState() {
            let button = (gameMode === 'ai-vs-ai') ? aiVsAiStartStopButton : startPauseButton;
            if (isGameOver) {
                button.textContent = '終了';
                button.disabled = true;
                button.classList.remove('paused');
            } else if (isGamePaused) {
                button.textContent = 'スタート';
                button.disabled = false;
                button.classList.remove('paused');
            } else {
                button.textContent = '一時停止';
                button.disabled = false;
                button.classList.add('paused');
            }
        }

        function quitGame() {
            if (isGameOver) return;
            isGameOver = true;
            isGamePaused = true;
            clearTimeout(roundResetTimeoutId);
            clearTimeout(notificationTimeoutId);
            if (gameMode === 'ai-vs-ai') {
                if (isAiVsAiRunning) stopAiVsAi();
                aiSpeedSlider.disabled = true;
                aiVsAiStartStopButton.disabled = true;
                hideElement(aiQuitButton);
            } else {
                enablePlayerChoices(false);
                startPauseButton.disabled = true;
                hideElement(quitButton);
                hideElement(turnIndicator);
            }
            let finalMessage = `勝負終了！ (${formatNumber(scores.player1)} 対 ${formatNumber(scores.player2)}`;
            if (scores.draw > 0) finalMessage += ` あいこ ${formatNumber(scores.draw)}回`;
            finalMessage += `) `;
            let p1FinalName = playerNameDisplay.textContent.split(':')[0].trim();
            let p2FinalName = aiNameDisplay.textContent.split(':')[0].trim();
            if (scores.player1 > scores.player2) finalMessage += `${p1FinalName}の勝ちです！`;
            else if (scores.player2 > scores.player1) finalMessage += `${p2FinalName}の勝ちです！`;
            else finalMessage += "引き分けです！";
            fadeInElementText(resultTextDisplay, finalMessage);
            showNotification(finalMessage, false, true, 4000);
            setTimeout(resetForNewGameSelection, 4500);
        }

        function playerChoose(playerHand) {
             if (isGamePaused || isGameOver) return;
             if (gameMode === 'player-vs-player' && currentPlayerTurn !== 'player1' && playerControlsDiv.contains(event.target)) return;
             if (gameMode === 'player-vs-player' && currentPlayerTurn !== 'player2' && aiNameDisplay.contains(event.target)) return;
             clearTimeout(roundResetTimeoutId);
             if (gameMode === 'player-vs-ai') {
                 enablePlayerChoices(false);
                 const aiHand = getAiHand(playerHistory);
                 playerHistory.push(playerHand);
                 const MAX_HISTORY = 500;
                 if (playerHistory.length > MAX_HISTORY) playerHistory.shift();
                 playRound(playerHand, aiHand);
             } else if (gameMode === 'player-vs-player') {
                 handlePlayerVsPlayerChoice(playerHand);
             }
        }

        function handlePlayerVsPlayerChoice(hand) {
            if (isGamePaused || isGameOver) return;
            if (currentPlayerTurn === 'player1') {
                player1HandChoice = hand;
                currentPlayerTurn = 'player2';
                resetHandDisplays();
                updateTurnIndicator();
                enablePlayerChoices(true);
                fadeInElementText(resultTextDisplay, getWaitingMessage());
                playerHandDisplay.textContent = '❔';
            } else {
                const player2HandChoice = hand;
                if (!player1HandChoice) return;
                enablePlayerChoices(false);
                playRound(player1HandChoice, player2HandChoice);
                player1HandChoice = null;
                currentPlayerTurn = 'player1';
            }
        }

        function playRound(hand1, hand2) {
             if (isGameOver) return;
             clearTimeout(roundResetTimeoutId);
             currentRound++;
             const winner = determineWinner(hand1, hand2);
             if (winner === 'player1') scores.player1++;
             else if (winner === 'player2') scores.player2++;
             else scores.draw++;
             updateScoreboard();
             updateRoundInfo();
             updateHandDisplays(hand1, hand2);
             let p1Name = playerNameDisplay.textContent.split(':')[0].trim();
             let p2Name = aiNameDisplay.textContent.split(':')[0].trim();
             let winnerName = '';
             if (winner === 'player1') winnerName = `${p1Name}の勝ち！`;
             else if (winner === 'player2') winnerName = `${p2Name}の勝ち！`;
             else winnerName = "あいこ！";
             fadeInElementText(resultTextDisplay, winnerName);
             updateChart();
             if (gameMode === 'player-vs-ai') saveGameData();
             checkGameEnd();
             if (!isGameOver && !isGamePaused) {
                 const delay = (gameMode === 'ai-vs-ai') ? Math.max(50, (1000 / aiVsAiSpeed) * 0.7) : 1000;
                 roundResetTimeoutId = setTimeout(() => {
                     if (isGameOver || isGamePaused) return;
                     resetHandDisplays();
                     fadeInElementText(resultTextDisplay, getWaitingMessage());
                     if (gameMode !== 'ai-vs-ai') {
                         enablePlayerChoices(true);
                         updateTurnIndicator();
                     }
                 }, delay);
             } else if (isGameOver) {
                 enablePlayerChoices(false);
                 updateStartPauseButtonState();
             }
        }

        function determineWinner(hand1, hand2) {
            if (hand1 === hand2) return 'draw';
            if (WIN_CONDITIONS[hand1] === hand2) return 'player1';
            return 'player2';
        }

        function getAiHand(history) {
            const historyLength = history.length;
            const explorationRate = 0.20;
            if (Math.random() < explorationRate || historyLength < 5) {
                return HANDS[Math.floor(Math.random() * HANDS.length)];
            }
            const lookback = Math.min(historyLength, 10);
            const recentHistory = history.slice(-lookback);
            const counts = recentHistory.reduce((acc, move) => {
                acc[move] = (acc[move] || 0) + 1;
                return acc;
            }, {});
            let mostFrequentMove = null;
            let maxCount = 0;
            for (const move in counts) {
                if (counts[move] > maxCount) {
                    maxCount = counts[move];
                    mostFrequentMove = move;
                } else if (counts[move] === maxCount) {
                    mostFrequentMove = null;
                }
            }
            if (mostFrequentMove && maxCount > lookback / 2.5) {
                const winningMove = Object.keys(WIN_CONDITIONS).find(key => WIN_CONDITIONS[key] === mostFrequentMove);
                if (winningMove) return winningMove;
            }
            const lastMove = history[historyLength - 1];
            const counterMove = Object.keys(WIN_CONDITIONS).find(key => WIN_CONDITIONS[key] === lastMove);
            if (counterMove && Math.random() < 0.6) {
                 return counterMove;
            }
            return HANDS[Math.floor(Math.random() * HANDS.length)];
        }

        function checkGameEnd() {
             if (isGameOver) return;
             if (currentGameLength !== Infinity && currentRound >= currentGameLength) {
                 isGameOver = true;
                 isGamePaused = true;
                 clearTimeout(roundResetTimeoutId);
                 let finalMessage = `勝負終了！ (${formatNumber(scores.player1)} 対 ${formatNumber(scores.player2)}`;
                 if (scores.draw > 0) finalMessage += ` あいこ ${formatNumber(scores.draw)}回`;
                 finalMessage += `) `;
                 let p1FinalName = playerNameDisplay.textContent.split(':')[0].trim();
                 let p2FinalName = aiNameDisplay.textContent.split(':')[0].trim();
                 if (scores.player1 > scores.player2) finalMessage += `${p1FinalName}の勝ちです！`;
                 else if (scores.player2 > scores.player1) finalMessage += `${p2FinalName}の勝ちです！`;
                 else finalMessage += "引き分けです！";
                 fadeInElementText(resultTextDisplay, finalMessage);
                 showNotification(finalMessage, false, true, 4000);
                 enablePlayerChoices(false);
                 if (gameMode === 'ai-vs-ai') {
                     if (isAiVsAiRunning) stopAiVsAi();
                     aiSpeedSlider.disabled = true;
                     aiVsAiStartStopButton.disabled = true;
                     hideElement(aiQuitButton);
                 } else {
                     startPauseButton.disabled = true;
                     hideElement(quitButton);
                     hideElement(turnIndicator);
                 }
                 updateStartPauseButtonState();
                 setTimeout(resetForNewGameSelection, 4500);
             }
        }

        function resetForNewGameSelection() {
             hideElement(gameAreaDiv);
             hideElement(chartContainerDiv);
             hideElement(playerControlsDiv);
             hideElement(aiVsAiControlsDiv);
             hideElement(turnIndicator);
             hideElement(zoomControlsDiv);
             hideElement(quitButton);
             hideElement(aiQuitButton);
             fadeInElement(modeSelectionDiv);
             hideElement(gameLengthSelectionDiv);
             if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
             chartData = { labels: [], datasets: [] };
             resetGameFullState();
             gameMode = '';
             updateScoreboard();
             resetHandDisplays();
             fadeInElementText(resultTextDisplay, '');
             fadeInElementText(roundInfoDisplay, '');
             if (isNotificationVisible) hideNotification(true);
        }

        function startAiVsAi() {
            if (isGameOver || isAiVsAiRunning) return;
            isAiVsAiRunning = true;
            isGamePaused = false;
            aiSpeedSlider.disabled = true;
            fadeInElementText(resultTextDisplay, '対戦中...');
            updateStartPauseButtonState();
            runAiVsAiRound();
        }

        function stopAiVsAi() {
            if (!isAiVsAiRunning && !isGamePaused && !isGameOver) return;
            isAiVsAiRunning = false;
            isGamePaused = true;
            clearInterval(aiVsAiIntervalId);
            aiVsAiIntervalId = null;
            if (!isGameOver) {
                aiSpeedSlider.disabled = false;
                fadeInElementText(resultTextDisplay, '一時停止中... 「スタート」で再開します。');
            } else {
                 aiSpeedSlider.disabled = true;
            }
            updateStartPauseButtonState();
        }

        function runAiVsAiRound() {
             if (isGameOver || isGamePaused || !isAiVsAiRunning) {
                 clearInterval(aiVsAiIntervalId);
                 aiVsAiIntervalId = null;
                 isAiVsAiRunning = false;
                 if (!isGameOver) updateStartPauseButtonState();
                 return;
             }
             const ai1Hand = getAiHand(ai2History);
             const ai2Hand = getAiHand(ai1History);
             ai1History.push(ai1Hand);
             ai2History.push(ai2Hand);
             const MAX_AI_HISTORY = 200;
             if (ai1History.length > MAX_AI_HISTORY) ai1History.shift();
             if (ai2History.length > MAX_AI_HISTORY) ai2History.shift();
             playRound(ai1Hand, ai2Hand);
             if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                 clearInterval(aiVsAiIntervalId);
                 aiVsAiIntervalId = null;
                 setTimeout(() => {
                     if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                         aiVsAiIntervalId = setInterval(runAiVsAiRound, 1000 / aiVsAiSpeed);
                    }
                 }, 50);
             } else {
                  clearInterval(aiVsAiIntervalId);
                  aiVsAiIntervalId = null;
             }
        }

        function updateSpeedDisplay(value) {
            aiVsAiSpeed = parseInt(value, 10);
            aiSpeedDisplay.textContent = aiVsAiSpeed;
            if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                clearInterval(aiVsAiIntervalId);
                aiVsAiIntervalId = null;
                setTimeout(() => {
                    if (isAiVsAiRunning && !isGamePaused && !isGameOver) {
                         aiVsAiIntervalId = setInterval(runAiVsAiRound, 1000 / aiVsAiSpeed);
                    }
                }, 50);
            }
        }

        function updateScoreboard() {
            let p1Label = playerNameDisplay.textContent.split(':')[0].trim() || 'Player 1';
            let p2Label = aiNameDisplay.textContent.split(':')[0].trim() || 'Player 2';
            fadeInElementText(scoreboardPlayerDisplay, `${p1Label}: ${formatNumber(scores.player1)}`);
            fadeInElementText(scoreboardDrawDisplay, `あいこ: ${formatNumber(scores.draw)}`);
            fadeInElementText(scoreboardAiDisplay, `${p2Label}: ${formatNumber(scores.player2)}`);
            const diff = scores.player1 - scores.player2;
            let diffText = '同点';
            if (diff > 0) diffText = `${p1Label} が ${formatNumber(diff)} リード`;
            else if (diff < 0) diffText = `${p2Label} が ${formatNumber(Math.abs(diff))} リード`;
            fadeInElementText(scoreDifferenceDisplay, diffText);
        }
        function updateRoundInfo() {
             const lengthDisplay = currentGameLength === Infinity ? '∞' : formatNumber(currentGameLength);
             fadeInElementText(roundInfoDisplay, `ラウンド: ${formatNumber(currentRound)} / ${lengthDisplay}`);
         }

        function updateTurnIndicator() {
             if (gameMode !== 'player-vs-player' || isGamePaused || isGameOver) {
                 hideElement(turnIndicator);
                 if (gameMode !== 'player-vs-player') {
                      playerControlsTitle.textContent = 'あなたの手を選択してください:';
                 }
                 return;
             }
             fadeInElement(turnIndicator);
             const turnPlayerName = (currentPlayerTurn === 'player1') ? playerNameDisplay.textContent.split(':')[0].trim() : aiNameDisplay.textContent.split(':')[0].trim();
             const message = `${turnPlayerName}の番: 手を選択してください`;
             fadeInElementText(turnIndicator, message);
             playerControlsTitle.textContent = `${turnPlayerName}の番:`;
         }

         function getWaitingMessage() {
             if (isGameOver) return resultTextDisplay.textContent;
             if (isGamePaused) return '一時停止中... 「スタート」で再開します。';
             if (currentRound === 0 && isGamePaused) return '「スタート」を押してゲームを開始してください。';
             if (gameMode === 'player-vs-ai') {
                 return 'あなたの手を選んでください。';
             } else if (gameMode === 'player-vs-player') {
                 const turnPlayerName = (currentPlayerTurn === 'player1') ? playerNameDisplay.textContent.split(':')[0].trim() : aiNameDisplay.textContent.split(':')[0].trim();
                 return `${turnPlayerName}の手を待っています...`;
             } else if (gameMode === 'ai-vs-ai') {
                 return '対戦中...';
             }
             return '結果を待っています...';
         }

        function updateHandDisplays(hand1, hand2) {
             playerHandDisplay.style.opacity = 0;
             aiHandDisplay.style.opacity = 0;
             playerHandDisplay.textContent = HAND_EMOJIS[hand1] || '?';
             aiHandDisplay.textContent = HAND_EMOJIS[hand2] || '?';
             void playerHandDisplay.offsetWidth;
             void aiHandDisplay.offsetWidth;
             playerHandDisplay.classList.add('fade-in');
             aiHandDisplay.classList.add('fade-in');
             playerHandDisplay.addEventListener('animationend', () => playerHandDisplay.classList.remove('fade-in'), { once: true });
             aiHandDisplay.addEventListener('animationend', () => aiHandDisplay.classList.remove('fade-in'), { once: true });
        }

         function resetHandDisplays() {
             clearTimeout(roundResetTimeoutId);
             playerHandDisplay.classList.remove('fade-in');
             aiHandDisplay.classList.remove('fade-in');
             playerHandDisplay.style.opacity = 1;
             aiHandDisplay.style.opacity = 1;
             playerHandDisplay.textContent = '?';
             aiHandDisplay.textContent = '?';
         }

         function enablePlayerChoices(enable) {
             playerChoiceButtons.forEach(button => {
                 button.disabled = !enable;
             });
         }

        function initializeChart() {
            if (chartInstance) chartInstance.destroy();
            const ctx = document.getElementById('resultsChart').getContext('2d');
            const colors = getChartColors();
            let p1Label = 'あなたの勝ち数', p2Label = 'AIの勝ち数';
             if (gameMode === 'ai-vs-ai') { p1Label = 'AI 1の勝ち数'; p2Label = 'AI 2の勝ち数'; }
             else if (gameMode === 'player-vs-player') { p1Label = 'あなたの勝ち数'; p2Label = 'ユーザー2の勝ち数'; }
             const diffLabel = 'スコア差';
            chartData = {
                labels: [0],
                datasets: [
                    { label: p1Label, data: [0], borderColor: colors.accent1, tension: 0, fill: false, yAxisID: 'y' },
                    { label: p2Label, data: [0], borderColor: colors.accent2, tension: 0, fill: false, yAxisID: 'y' },
                    { label: 'あいこ', data: [0], borderColor: colors.accent3, tension: 0, fill: false, yAxisID: 'y' },
                    { label: diffLabel, data: [0], borderColor: colors.accent4, tension: 0, fill: false, borderDash: [5, 5], yAxisID: 'y1' }
                ]
            };
            if(zoomToggleSwitch) zoomToggleSwitch.checked = isZoomEnabled;
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true, maintainAspectRatio: false,
                    animation: { duration: gameMode === 'ai-vs-ai' ? 0 : 200 },
                    scales: {
                         y: {
                             type: 'linear', display: true, position: 'left',
                             grid: { color: colors.gridColor },
                             ticks: { color: colors.labelColor, callback: value => formatNumber(value), beginAtZero: true },
                             grace: '10%',
                             title: { display: true, text: '累計スコア', color: colors.titleColor }
                         },
                        y1: {
                            type: 'linear', display: true, position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { color: colors.labelColor, callback: value => formatNumber(value) },
                            grace: '10%',
                            title: { display: true, text: diffLabel, color: colors.titleColor }
                        },
                        x: {
                            grid: { color: colors.gridColor },
                            ticks: {
                                color: colors.labelColor,
                                callback: function(value) {
                                    const label = this.getLabelForValue(value);
                                     if (typeof label === 'number' && label % 1 === 0) { return formatNumber(label); }
                                     return formatNumber(label);
                                },
                                maxTicksLimit: 15, autoSkip: true
                             },
                            title: { display: true, text: 'ラウンド数', color: colors.titleColor }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: colors.labelColor } },
                        title: { display: true, text: '勝負の推移', color: colors.titleColor, font: { size: 16 } },
                        zoom: {
                            pan: { enabled: isZoomEnabled, mode: 'xy', threshold: 5 },
                            zoom: { wheel: { enabled: isZoomEnabled }, pinch: { enabled: isZoomEnabled }, mode: 'xy', drag: { enabled: false } }
                        }
                    },
                    elements: { point:{ radius: 0 }, line: { borderWidth: 2 } },
                    interaction: { mode: 'index', intersect: false },
                    hover: { mode: 'nearest', intersect: false }
                }
            });
            updateChartColors();
        }

        function resetZoom() { if (chartInstance) chartInstance.resetZoom(); }
        function toggleZoomSwitch(isChecked) { isZoomEnabled = isChecked; enableZoom(isZoomEnabled); }
        function enableZoom(enable) {
            if (!chartInstance) return;
            chartInstance.options.plugins.zoom.zoom.wheel.enabled = enable;
            chartInstance.options.plugins.zoom.zoom.pinch.enabled = enable;
            chartInstance.options.plugins.zoom.pan.enabled = enable;
            chartInstance.update('none');
        }

        function updateChart() {
            if (!chartInstance || !chartData) return;
            const scoreDiff = scores.player1 - scores.player2;
            chartData.labels.push(currentRound);
            chartData.datasets[0].data.push(scores.player1);
            chartData.datasets[1].data.push(scores.player2);
            chartData.datasets[2].data.push(scores.draw);
            chartData.datasets[3].data.push(scoreDiff);
            const MAX_CHART_POINTS = 200;
            if (chartData.labels.length > MAX_CHART_POINTS) {
                const shiftAmount = chartData.labels.length - MAX_CHART_POINTS;
                chartData.labels.splice(0, shiftAmount);
                chartData.datasets.forEach(dataset => dataset.data.splice(0, shiftAmount));
            }
            chartInstance.update('none');
        }

        function showNotification(message, showConfirm = false, isSuccess = false, autoHideDelay = 4000) {
            if (notificationTimeoutId) { clearTimeout(notificationTimeoutId); notificationTimeoutId = null; }
            if (isNotificationVisible) {
                notificationArea.style.opacity = 0;
                 setTimeout(() => { _displayNotification(message, showConfirm, isSuccess, autoHideDelay); }, 150);
            } else {
                 _displayNotification(message, showConfirm, isSuccess, autoHideDelay);
            }
        }
        function _displayNotification(message, showConfirm, isSuccess, autoHideDelay){
             isNotificationVisible = false;
             notificationMessage.textContent = message;
             notificationArea.style.display = 'block';
             notificationArea.style.opacity = 0;
             void notificationArea.offsetWidth;
             notificationArea.classList.add('fade-in');
             isNotificationVisible = true;
             if (!showConfirm && autoHideDelay > 0) {
                 notificationTimeoutId = setTimeout(() => {
                      if (isNotificationVisible) { hideNotification(); }
                      notificationTimeoutId = null;
                 }, autoHideDelay);
             }
        }
        function hideNotification(immediately = false) {
            if (!isNotificationVisible) return;
            if (notificationTimeoutId) { clearTimeout(notificationTimeoutId); notificationTimeoutId = null; }
            isNotificationVisible = false;
            if (immediately) {
                 notificationArea.style.opacity = 0;
                 notificationArea.style.display = 'none';
                 notificationArea.classList.remove('fade-in');
            } else {
                notificationArea.style.opacity = 0;
                setTimeout(() => {
                    if (!isNotificationVisible) {
                         notificationArea.style.display = 'none';
                         notificationArea.classList.remove('fade-in');
                    }
                }, 300);
            }
        }

         function resetScoresAndHistories() {
             scores = { player1: 0, player2: 0, draw: 0 };
             ai1History = [];
             ai2History = [];
         }
         function resetGameFullState() {
             resetScoresAndHistories();
             currentRound = 0;
             isGameOver = false;
             isGamePaused = true;
             isAiVsAiRunning = false;
             currentPlayerTurn = 'player1';
             player1HandChoice = null;
             clearTimeout(roundResetTimeoutId);
             clearTimeout(notificationTimeoutId);
             clearInterval(aiVsAiIntervalId);
             aiVsAiIntervalId = null;
         }

        function saveGameData() {
             if (gameMode === 'player-vs-ai') {
                 try {
                    const MAX_SAVE_HISTORY = 1000;
                    const historyToSave = playerHistory.slice(-MAX_SAVE_HISTORY);
                    localStorage.setItem('rpsGameData', JSON.stringify({ playerHistory: historyToSave }));
                 } catch (e) { console.error("Error saving game data:", e); }
             }
        }
        function loadGameData() {
             try {
                const savedData = localStorage.getItem('rpsGameData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    const MAX_LOAD_HISTORY = 1000;
                    playerHistory = Array.isArray(parsedData.playerHistory) ? parsedData.playerHistory.slice(-MAX_LOAD_HISTORY) : [];
                } else { playerHistory = []; }
             } catch (e) { console.error("Error loading game data:", e); playerHistory = []; }
        }

        function formatNumber(num) {
            if (typeof num !== 'number' || !isFinite(num)) {
                if (num === Infinity) return '∞';
                if (isNaN(num)) return '?';
                return num ? String(num) : '0';
            }
            const sign = num < 0 ? '-' : '';
            let absNum = Math.abs(num);
            const googol = 1e100;
            if (absNum >= googol) {
                 let unitKey = null;
                 for (const key of UNIT_KEYS.reverse()) {
                     if (absNum >= Math.pow(10, key)) { unitKey = key; break; }
                 }
                  UNIT_KEYS.reverse();
                 if (unitKey) {
                    const value = absNum / Math.pow(10, unitKey);
                    return sign + value.toFixed(2).replace(/(\.0+|(?<=\.\d)0+)$/, '') + UNITS[unitKey];
                 } else { return sign + absNum.toExponential(2); }
            }
            for (const key of UNIT_KEYS) {
                const threshold = Math.pow(10, key);
                if (absNum >= threshold) {
                    const value = absNum / threshold;
                    let formattedNum;
                    if (value < 10) { formattedNum = value.toFixed(2); }
                    else if (value < 100) { formattedNum = value.toFixed(1); }
                    else { formattedNum = value.toFixed(0); }
                    formattedNum = formattedNum.replace(/(\.0+|(?<=\.\d)0+)$/, '');
                    return sign + formattedNum + UNITS[key];
                }
            }
             if (absNum < 1000) { return sign + absNum.toString(); }
             return sign + absNum.toString();
        }

        function fadeInElement(element) {
            if (!element) return;

            const computedStyle = getComputedStyle(element);
            const currentOpacity = parseFloat(computedStyle.opacity);
            const isDisplayed = computedStyle.display !== 'none';

            // 1. 既に完全に表示されていれば何もしない
            if (isDisplayed && currentOpacity === 1 && !element.classList.contains('fade-in')) {
                element.classList.remove('initially-hidden'); // クラス整理
                return;
            }

            // 2. CSSによる初期アニメーションが進行中の場合は干渉しない
            // ただし、initially-hiddenだった要素はJSが明示的にアニメーションさせる
            if (isDisplayed && currentOpacity > 0 && currentOpacity < 1 &&
                computedStyle.animationName && computedStyle.animationName.includes('fadeIn') &&
                !element.classList.contains('initially-hidden-triggered-by-js')) { // JSトリガーの目印がない場合
                // console.log("fadeInElement: CSS animation in progress for", element.id || element.className, ", JS will not interfere.");
                return;
            }

            // --- JavaScriptがフェードインを実行するケース ---
            element.classList.remove('initially-hidden'); // 隠すクラスを除去
            element.classList.add('initially-hidden-triggered-by-js'); // JSが処理したことを示す（上記2の判定用）

            const displayStyle = element.classList.contains('zoom-controls') ||
                                 element.id === 'player-controls' ||
                                 element.id === 'ai-vs-ai-controls' ? 'flex' : 'block';

            // アニメーションクラスを一度除去してリフローを挟むことで、再適用時にアニメーションが発火するようにする
            if (element.classList.contains('fade-in')) {
                element.classList.remove('fade-in');
                void element.offsetWidth; // リフロー
            }

            element.style.display = displayStyle; // 表示形式を設定
            element.style.opacity = 0;    // 透明から開始
            void element.offsetWidth;      // リフローして opacity:0 を適用

            element.classList.add('fade-in'); // アニメーションクラスを付与

            element.addEventListener('animationend', function handler() {
                element.classList.remove('fade-in'); // クラス除去
                element.style.opacity = 1;         // 最終状態
                element.classList.remove('initially-hidden-triggered-by-js'); // 目印を除去
                // { once: true } を使わない場合はリスナーも除去: element.removeEventListener('animationend', handler);
            }, { once: true });

            // フォールバックタイマー
            setTimeout(() => {
                if (element.classList.contains('fade-in')) { // まだアニメーション中なら
                    element.classList.remove('fade-in');
                    element.style.opacity = 1;
                }
                // アニメーションクラスがなくても、何らかの理由で透明なままなら表示
                else if (getComputedStyle(element).display !== 'none' && parseFloat(getComputedStyle(element).opacity) < 1) {
                    element.style.opacity = 1;
                }
                element.classList.remove('initially-hidden-triggered-by-js'); // 目印を除去
            }, 550); // アニメーション時間 (0.5s) + バッファ
        }


        function hideElement(element) {
            if (!element) return;
            if (element.style.display === 'none') return;
            element.style.opacity = 0;
            element.classList.remove('fade-in');
             element.classList.remove('initially-hidden-triggered-by-js'); // JSトリガーの目印も除去
            setTimeout(() => {
                 if (element.style.opacity === '0') {
                      element.style.display = 'none';
                 }
            }, 300);
        }

         function fadeInElementText(element, text) {
             if (!element) return;
             const isVisible = element.style.display !== 'none' && element.style.opacity !== '0';
             if (element.textContent === text && isVisible) return;
             if (isVisible) {
                 element.style.transition = 'opacity 0.15s ease-out';
                 element.style.opacity = 0;
                 setTimeout(() => {
                     element.textContent = text;
                     if (element.style.display === 'none') element.style.display = '';
                     element.style.opacity = 1;
                     setTimeout(() => element.style.transition = '', 150);
                 }, 150);
             } else {
                 element.textContent = text;
                 if (element.style.display === 'none') {
                      element.style.opacity = 0; // fadeInElement がこれを拾ってアニメーション開始
                 }
             }
         }
    </script>
</body>
</html>
